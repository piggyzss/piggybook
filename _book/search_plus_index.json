{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 最近参加面试的过程中，将自己前端知识树重新梳立了一遍，现汇总整理如下，不仅作为自己准备面试的map，也是对以往学习内容的集中复盘和回顾。 内容主要分为Javascript、html、浏览器、http、安全、性能、React、算法、数据结构、设计模式、前端构建，后续会视情况陆续补充node、vue等内容。 如果你有好的意见或建议，请邮件联系我1158591034@qq.com。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:37:36 "},"Chapter1/":{"url":"Chapter1/","title":"第一章 Javascript","keywords":"","body":"第一章 Javascript 第1节：基础 第2节：原理性实现 第3节：常见解决方法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 22:54:23 "},"Chapter1/基础.html":{"url":"Chapter1/基础.html","title":"第1节：基础","keywords":"","body":"第1节： 基础 1、数据类型 2、this 3、执行上下文 4、闭包 5、原型 6、继承 7、作用域和作用域链 1、数据类型 数据类型 基本类型：Number，String，Boolean，Symbol，Undefined，Null 引用类型：Object，Array，Function 数据类型判断 typeof typeof 返回的是字符串，有六种可能： \"number\"、\"string\"、\"boolean\"、\"object\"、\"function\"、\"undefined\" typeof null --> \"object\" typeof [1,2,3] --> \"object\" typeof NaN --> \"number\" Object.prototype.toString.call 利用object的原型方法toString能返回相应的类型： Object.prototype.toString.call(999) *// \"[object Number]\"* Object.prototype.toString.call('') *// \"[object String]\"* Object.prototype.toString.call(true) *// \"[object Boolean]* Object.prototype.toString.call(Symbol()) *// \"[object Symbol]\"* Object.prototype.toString.call(null) *// \"[object Null]\"* Object.prototype.toString.call(undefined) *// \"[object Undefined]\"* Object.prototype.toString.call({a:1}) *// \"[object Object]\"* Object.prototype.toString.call([1,2]) *// \"[object Array]\"* Object.prototype.toString.call(function(){}) *// \"[object Function]\"* instanceof 判断构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。 [1,2] instanceof Array *// true* (function(){}) instanceof Function *// true* ({a:1}) instanceof Object *// true* constructor 2、this this 的四种绑定规则 this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。 默认绑定 最常用也是函数调用类型，当只有一个独立函数时，this指向的是window对象 在严格模式下（\"use strict\";），全局对象将无法使用默认绑定，即执行会报undefined的错误 隐式绑定 函数是作为某个对象的方法调用的，即调用位置上存在上下文对象。 this进行了隐式绑定，即this绑定到了对象obj上 显式绑定 显式绑定就是通过apply，call，bind，直接将函数中的this绑定到想要的对象上 显式绑定主要是通过改变对象的proto关联对象 new 绑定 使用new操作符，可以将函数的this指向新创建的对象。 优先级：new绑定 > 显式绑定 >隐式绑定 > 默认绑定 判断this绑定的顺序： （1）判断是否是new调用，是的话就是new绑定，函数中的this会指向新构造的对象。 （2）判断是否是显示绑定，即是否是通过函数原型中的apply方法或者call方法调用 （还要注意bind返回的函数，this指向也会被修改）。 （3）判断是否是隐式绑定，及通过某个对象调用。是的话，this会指向所属对象。 （4）如果都没有的话，就是默认绑定，this指向全局对象window；严格模式下指向undefined。 3、执行上下文 This is x y z. 4、闭包 This is x y z. 5、原型 This is x y z. 6、继承 This is x y z. 7、作用域和作用域链 This is x y z. Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 12:08:57 "},"Chapter1/原理性实.html":{"url":"Chapter1/原理性实.html","title":"第2节：原理性实现","keywords":"","body":"第2节： 原理性实现 1、debounce 2、throttle 3、bind、call、apply 4、实现instanceof 5、实现柯里化函数 6、实现compose和pipe 7、实现new 1、debounce 防抖的原理是：在事件被触发后不马上执行回调，n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 function debounce(func: Function, wait = 500) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer: any = null return function(...args: any[]) { timer && clearTimeout(timer) timer = setTimeout(() => { func(...args) }, wait) } } 2、throttle 节流的原理是：让一个函数不要执行得太频繁，减少一些过快的函数调用来节流。也就是在一段固定的时间内只触发一次回调函数 时间戳版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } // 第一次先打一个初始时间戳设置为0 var previous = 0 return function () { // 通过date.now取到当前时间，二者相减如果大于时间间隔，则调用传入的func，并且把时间戳previous设置为now var now = Date.now() if (now - previous > wait) { func.apply(this, [...arguments]) previous = now } } } 定时器版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer = null return function() { // 如果判断出定时器timer为空，则会起定时器赋值给timer，定时器的回调处理函数中调用传入的func，并且清空定时器 if (!timer) { timer = setTimeout(function(){ timer = null func.apply(this, [...arguments]) }, wait) } } } 3、bind、call、apply call Function.prototype.Call = function (context) { var context = context || window // 给 context 添加一个属性 context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.Apply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind Function.prototype.Bind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { var context = context || window context.fn = this var result if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } } 4、实现instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 5、实现柯里化函数 function curry(fn) { var _this = this return function inner(...args) { // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (**args.length inner.call(_this, ...args, ...innerArgs)** } // 参数收集完毕，则执行fn return fn.apply(this, args) } } 扩展题目 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add() { var _args = [...arguments] return function() { if (arguments.length === 0) { return _args.reduce(function (a, b) { return a + b }) } [].push.apply(_args, [...arguments]) return arguments.callee } } add(1, 2)(1)(2)(5)() 6、实现compose和pipe 实现函数compose，compose接受多个函数作为参数，并返回一个新的函数，新的函数会从右向左依次执行原函数， 并且上一次结果的返回值将会作为下一个函数的参数。 function compose(...fns) { return (...args) => fns.reduceRight((acc, cur) => cur(acc), ...args); } compose 的数据流是从右至左的，因为最右侧的函数首先执行，将数据 传递给下一个函数，以此类推 ...... 最左侧的函数最后执行；而管道的数据流是 从左至右的。 实现一个管道函数： const pipe = (...fns) => (...args) => fns.reduce((acc, cur) => cb(cur) , args) 7、实现new 创建一个空的新对象 新对象的proto属性指向构造函数的原型对象 绑定this，执行构造函数 返回新对象 function create () { let obj = new Object() let constructor = [].shift.apply(arguments) obj.__proto__ = constructor.prototype let result = constructor.apply(obj, arguments) return typeof result === \"object\" ? result : obj } 8、实现Promise 规范 Promise规范有很多，如Promise/A，Promise/B，Promise/D以及 Promise/A的升级版 Promise/A+。ES6中采用了 Promise/A+规范。 英文版规范: Promises/A+规范 中文版规范: Promises/A+规范(中文) Promise标准解读 (1) 一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。 (2) promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then方法可以被同一个 promise调用多次。 Promise实现 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 15:57:03 "},"Chapter1/常见解决方法.html":{"url":"Chapter1/常见解决方法.html","title":"第3节：常见解决方法","keywords":"","body":"第3节：常见解决方法 1、深拷贝 2、实现一个ajax 3、数组去重 4、周期性执行一个函数n次 5、基于promise实现重试功能 6、实现一个休眠函数 1、深拷贝 function deepCopy(src){ if (!src | !(src instanceof Object) | (typeof src === \"function\")) { return src || undefined } var constructor = src.constructor var dst = new constructor() for (var key in src) { if (src.hasOwnProperty(key)) { dst[key] = deepCopy(src[key]) } } return dst } 2、实现一个ajax function getData(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onreadystatechange = handler; xhr.responseType = \"json\"; xhr.setRequestHeader(\"Accept\", \"application/json\"); xhr.send(); }); return promise; }; 3、数组去重 set去重 [...(new set([]))] 基本数组去重 Array.prototype.unique = function() { var result = [] this.forEach((val) => { if(result.indexOf(val) 利用hash表去重，空间换时间 ** Array.prototype.unique = function() { var hash = {} var result = [] this.forEach((val) => { if(!hash[val]) { obj[val] = true result.push(val) } }) return result } 4、周期性执行一个函数n次 function circlExe(fn, wait=0, num=0){ var count = 0 function inner() { if(count >= num) { return } count++ setTimeout(() => { inner.call(this, ...arguments) fn.call(this, ...arguments) }, wait) } return inner } 5、基于promise实现重试功能 function getData(delay){ return new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num 打印结果： 随机数生成的值： 17 还有 5 次尝试 随机数生成的值： 15 还有 4 次尝试 随机数生成的值： 16 还有 3 次尝试 随机数生成的值： 20 还有 2 次尝试 随机数生成的值： 16 还有 1 次尝试 随机数生成的值： 15 还有 0 次尝试 6、实现一个休眠函数 封装一个休眠函数，入参是定时器的等待时间，.then执行回调函数 function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 15:46:02 "},"Chapter2/":{"url":"Chapter2/","title":"第二章 HTML & CSS","keywords":"","body":"第二章 HTML & CSS Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 浏览器","keywords":"","body":"第三章 浏览器 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 http","keywords":"","body":"第四章 http Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 安全","keywords":"","body":"第五章 安全 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 性能","keywords":"","body":"第六章 性能 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter7/":{"url":"Chapter7/","title":"第七章 React","keywords":"","body":"第七章 React Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter8/":{"url":"Chapter8/","title":"第八章 算法","keywords":"","body":"第八章 算法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter9/":{"url":"Chapter9/","title":"第九章 数据结构","keywords":"","body":"第九章 数据结构 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter10/":{"url":"Chapter10/","title":"第十章 设计模式","keywords":"","body":"第十章 设计模式 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "},"Chapter11/":{"url":"Chapter11/","title":"第十一章 前端构建","keywords":"","body":"第十一章 前端构建 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-15 21:26:16 "}}