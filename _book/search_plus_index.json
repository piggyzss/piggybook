{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 最近参加面试的过程中，将自己前端知识树重新梳立了一遍，现汇总整理如下，不仅作为自己准备面试的map，也是对以往学习内容的集中复盘和回顾。 内容主要分为Javascript、html、浏览器、http、安全、性能、React、算法、数据结构、设计模式、前端构建，后续会视情况陆续补充node、vue等内容。 如果你有好的意见或建议，请邮件联系我1158591034@qq.com。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 23:06:48 "},"Chapter1/":{"url":"Chapter1/","title":"第一章 Javascript","keywords":"","body":"第一章 Javascript 第1节：基础 第2节：原理性实现 第3节：常见解决方法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter1/基础.html":{"url":"Chapter1/基础.html","title":"第1节：基础","keywords":"","body":"第1节： 基础 1、数据类型 2、this 3、执行上下文 4、闭包 5、原型 6、继承 7、作用域和作用域链 1、数据类型 数据类型 基本类型：Number，String，Boolean，Symbol，Undefined，Null 引用类型：Object，Array，Function 数据类型判断 typeof typeof 返回的是字符串，有六种可能： \"number\"、\"string\"、\"boolean\"、\"object\"、\"function\"、\"undefined\" typeof null --> \"object\" typeof [1,2,3] --> \"object\" typeof NaN --> \"number\" Object.prototype.toString.call 利用object的原型方法toString能返回相应的类型： Object.prototype.toString.call(999) *// \"[object Number]\"* Object.prototype.toString.call('') *// \"[object String]\"* Object.prototype.toString.call(true) *// \"[object Boolean]* Object.prototype.toString.call(Symbol()) *// \"[object Symbol]\"* Object.prototype.toString.call(null) *// \"[object Null]\"* Object.prototype.toString.call(undefined) *// \"[object Undefined]\"* Object.prototype.toString.call({a:1}) *// \"[object Object]\"* Object.prototype.toString.call([1,2]) *// \"[object Array]\"* Object.prototype.toString.call(function(){}) *// \"[object Function]\"* instanceof 判断构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。 [1,2] instanceof Array *// true* (function(){}) instanceof Function *// true* ({a:1}) instanceof Object *// true* constructor 2、this this 的四种绑定规则 this的4种绑定规则分别是：默认绑定、隐式绑定、显示绑定、new 绑定。优先级从低到高。 默认绑定 最常用也是函数调用类型，当只有一个独立函数时，this指向的是window对象 在严格模式下（\"use strict\";），全局对象将无法使用默认绑定，即执行会报undefined的错误 隐式绑定 函数是作为某个对象的方法调用的，即调用位置上存在上下文对象。 this进行了隐式绑定，即this绑定到了对象obj上 显式绑定 显式绑定就是通过apply，call，bind，直接将函数中的this绑定到想要的对象上 显式绑定主要是通过改变对象的proto关联对象 new 绑定 使用new操作符，可以将函数的this指向新创建的对象。 优先级：new绑定 > 显式绑定 >隐式绑定 > 默认绑定 判断this绑定的顺序： （1）判断是否是new调用，是的话就是new绑定，函数中的this会指向新构造的对象。 （2）判断是否是显示绑定，即是否是通过函数原型中的apply方法或者call方法调用 （还要注意bind返回的函数，this指向也会被修改）。 （3）判断是否是隐式绑定，及通过某个对象调用。是的话，this会指向所属对象。 （4）如果都没有的话，就是默认绑定，this指向全局对象window；严格模式下指向undefined。 3、执行上下文 This is x y z. 4、闭包 定义：函数访问了上层作用域的变量，并且在当前作用域之外执行，就会形成闭包 判定准则：执行时是否在内部定义的函数中访问了上层作用域的变量。 函数与创建该函数的词法环境（lexical environment）共同构成闭包（closure）。这个环境指的是函数创建时，它可以访问的所有变量。 5、原型 This is x y z. 6、继承 This is x y z. 7、作用域和作用域链 This is x y z. Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-17 15:30:18 "},"Chapter1/原理性实.html":{"url":"Chapter1/原理性实.html","title":"第2节：原理性实现","keywords":"","body":"第2节： 原理性实现 1、debounce 2、throttle 3、bind、call、apply 4、实现instanceof 5、实现柯里化函数 6、实现compose和pipe 7、实现new 1、debounce 防抖的原理是：在事件被触发后不马上执行回调，n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 function debounce(func: Function, wait = 500) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer: any = null return function(...args: any[]) { timer && clearTimeout(timer) timer = setTimeout(() => { func(...args) }, wait) } } 2、throttle 节流的原理是：让一个函数不要执行得太频繁，减少一些过快的函数调用来节流。也就是在一段固定的时间内只触发一次回调函数 时间戳版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } // 第一次先打一个初始时间戳设置为0 var previous = 0 return function () { // 通过date.now取到当前时间，二者相减如果大于时间间隔，则调用传入的func，并且把时间戳previous设置为now var now = Date.now() if (now - previous > wait) { func.apply(this, [...arguments]) previous = now } } } 定时器版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer = null return function() { // 如果判断出定时器timer为空，则会起定时器赋值给timer，定时器的回调处理函数中调用传入的func，并且清空定时器 if (!timer) { timer = setTimeout(function(){ timer = null func.apply(this, [...arguments]) }, wait) } } } 3、bind、call、apply call Function.prototype.Call = function (context) { var context = context || window // 给 context 添加一个属性 context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.Apply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind Function.prototype.Bind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { var context = context || window context.fn = this var result if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } } 4、实现instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 5、实现柯里化函数 function curry(fn) { var _this = this return function inner(...args) { // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (**args.length inner.call(_this, ...args, ...innerArgs)** } // 参数收集完毕，则执行fn return fn.apply(this, args) } } 扩展题目 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add() { var _args = [...arguments] return function() { if (arguments.length === 0) { return _args.reduce(function (a, b) { return a + b }) } [].push.apply(_args, [...arguments]) return arguments.callee } } add(1, 2)(1)(2)(5)() 6、实现compose和pipe 实现函数compose，compose接受多个函数作为参数，并返回一个新的函数，新的函数会从右向左依次执行原函数， 并且上一次结果的返回值将会作为下一个函数的参数。 function compose(...fns) { return (...args) => fns.reduceRight((acc, cur) => cur(acc), ...args); } compose 的数据流是从右至左的，因为最右侧的函数首先执行，将数据 传递给下一个函数，以此类推 ...... 最左侧的函数最后执行；而管道的数据流是 从左至右的。 实现一个管道函数： const pipe = (...fns) => (...args) => fns.reduce((acc, cur) => cb(cur) , args) 7、实现new 创建一个空的新对象 新对象的proto属性指向构造函数的原型对象 绑定this，执行构造函数 返回新对象 function create () { let obj = new Object() let constructor = [].shift.apply(arguments) obj.__proto__ = constructor.prototype let result = constructor.apply(obj, arguments) return typeof result === \"object\" ? result : obj } 8、实现Promise 规范 Promise规范有很多，如Promise/A，Promise/B，Promise/D以及 Promise/A的升级版 Promise/A+。ES6中采用了 Promise/A+规范。 英文版规范: Promises/A+规范 中文版规范: Promises/A+规范(中文) Promise标准解读 (1) 一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。 (2) promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then方法可以被同一个 promise调用多次。 Promise实现 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter1/常见解决方法.html":{"url":"Chapter1/常见解决方法.html","title":"第3节：常见解决方法","keywords":"","body":"第3节：常见解决方法 1、深拷贝 2、实现一个ajax 3、数组去重 4、周期性执行一个函数n次 5、基于promise实现重试功能 6、实现一个休眠函数 1、深拷贝 function deepCopy(src){ if (!src | !(src instanceof Object) | (typeof src === \"function\")) { return src || undefined } var constructor = src.constructor var dst = new constructor() for (var key in src) { if (src.hasOwnProperty(key)) { dst[key] = deepCopy(src[key]) } } return dst } 2、实现一个ajax function getData(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onreadystatechange = handler; xhr.responseType = \"json\"; xhr.setRequestHeader(\"Accept\", \"application/json\"); xhr.send(); }); return promise; }; 3、数组去重 set去重 [...(new set([]))] 基本数组去重 Array.prototype.unique = function() { var result = [] this.forEach((val) => { if(result.indexOf(val) 利用hash表去重，空间换时间 ** Array.prototype.unique = function() { var hash = {} var result = [] this.forEach((val) => { if(!hash[val]) { obj[val] = true result.push(val) } }) return result } 4、周期性执行一个函数n次 function circlExe(fn, wait=0, num=0){ var count = 0 function inner() { if(count >= num) { return } count++ setTimeout(() => { inner.call(this, ...arguments) fn.call(this, ...arguments) }, wait) } return inner } 5、基于promise实现重试功能 function getData(delay){ return new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num 打印结果： 随机数生成的值： 17 还有 5 次尝试 随机数生成的值： 15 还有 4 次尝试 随机数生成的值： 16 还有 3 次尝试 随机数生成的值： 20 还有 2 次尝试 随机数生成的值： 16 还有 1 次尝试 随机数生成的值： 15 还有 0 次尝试 6、实现一个休眠函数 封装一个休眠函数，入参是定时器的等待时间，.then执行回调函数 function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter2/":{"url":"Chapter2/","title":"第二章 HTML & CSS","keywords":"","body":"第二章 HTML & CSS Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 浏览器","keywords":"","body":"第三章 浏览器 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 http","keywords":"","body":"第四章 http 1、http消息结构组成 2、列举常用的http方法并介绍get与post请求的区别 3、常见的http状态码 4、http/1.1相比http/1.0有什么优点 5、http/2.0有哪些新特性 6、简述https工作原理 7、TCP协议 8、什么是CDN 1、http消息结构组成 HTTP消息结构组成 客户端请求消息：请求行、请求头部、请求正文 服务器响应消息：状态行、响应头、响应正文 1.1、 请求报文 请求行 请求方法 URL 协议/版本 GET www.baidu.com HTTP/1.1 请求头部 头部字段名 + 冒号（:） + 值 + 回车符 + 换行符 参考文章：《HTTP常用头部信息》 场景： RequestHeader 例子 描述 Host www.uuid.online 请求的目标域名和端口号 Origin http://localhost:8081/ 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息） Referer https:/localhost:8081/link?query=xxxxx 请求资源的完整URI User-Agent Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 浏览器信息 Cookie BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0 当前域名下的Cookie Accept text/html,image/png 代表客户端希望接受的数据类型是html或者是png图片类型 Accept-Encoding gzip, deflate 代表客户端能支持什么样的压缩格式 Accept-Language zh-CN,zh;q=0.9 代表客户端可以支持语言 zh-CN 或者 zh (值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里 zh-CN 是1， zh 是0.9) Connection keep-alive 告诉服务器，客户端需要的 tcp 连接是一个长连接 请求正文 一般使用在 POST 方法中， GET 方法不存在请求正文。 POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。 1.2、 响应报文 状态行 协议版本 状态码 状态码描述 HTTP/1.1 200 OK 常见的状态码： 状态码 说明 200 响应成功 302 跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别） 304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400 客户端请求有语法错误，不能被服务器识别 403 服务器接收到请求，但是拒绝提供服务（认证失败） 404 请求资源不存在 500 服务器内部错误 响应头部 参考文章：《HTTP常用头部信息》 举例： Response Header 描述 Date: Mon, 30 Jul 2018 02:50:55 GMT 服务端发送资源时的服务器时间 Expires: Wed, 31 Dec 1969 23:59:59 GMT 较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页 Cache-Control: no-cache 现在最多使用的控制缓存的方式，会和服务器进行缓存验 etag: \"fb8ba2f80b1d324bb997cbe188f28187-ssl-df\" 一般是Nginx静态服务器发来的静态文件签名，浏览在没有 “Disabled cache” 情况下，接收到 etag 后，同一个 url 第二次请求就会自动带上 “If-None-Match” Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT 服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容 Content-Type: text/html; charset=utf-8 如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码 Content-Encoding: gzip 告诉客户端，应该采用gzip对资源进行解码 Connection: keep-alive 告诉客户端服务器的tcp连接也是一个长连接 响应正文 2、列举常用的http方法并介绍get与post请求的区别 2.1、 http请求方法 根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP/1.0 定义了三种请求方法： GET, POST, PUT, DELETE和HEAD方法。 HTTP/1.1 新增了五种请求方法：OPTIONS, TRACE和CONNECT方法。 方法 描述 GET 请求指定的页面信息，并返回实体主体。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 PATCH 实体中包含一个表，表中说明与该URI所表示的原内容的区别。 MOVE 请求服务器将指定的页面移至另一个网络地址。 COPY 请求服务器将指定的页面拷贝至另一个网络地址。 LINK 请求服务器建立链接关系。 UNLINK 断开链接关系。 WRAPPED 允许客户端发送经过封装的请求。 Extension-mothed 在不改动协议的前提下，可增加另外的方法。 2.2、get与post请求的区别 区别内容 GET POST 点击返回/刷新按钮 没有影响 数据会重新发送（浏览器将会提示“数据被重新提交”） 缓存 可以 不可以 历史记录 有 没有 长度限制 有 没有 安全性 查询字符串会显示在地址栏的 URL 上，不安全，请不要使用 GET 请求提交敏感数据 因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，请使用数据加密。 可见性 查询字符串在地址栏的 URL 中可见 查询字符串在地址栏的 URL 中不可见 数据类型限制 只允许 ASCLll 字符类型 没有限制，允许二进制数据 添加书签 可以 不可以 get会产生一个tcp数据包，post两个。 具体就是： get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据） post请求时，浏览器先发送headers，服务器响应100continue，浏览器再发送data，服务器响应200（返回数据）。 这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现） 3、常见的http状态码 状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 100 客户必须继续发出请求 101 客户要求服务器根据请求转换HTTP协议版本 2xx：成功–表示请求已被成功接收、处理 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 3xx：重定向–要完成请求必须进行更进一步的操作。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304（使用缓存）自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 4xx：客户端错误–请求有语法错误或请求无法实现。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 资源未找到 5xx：服务器端错误–服务器未能实现合法的请求。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 4、http/1.1相比http/1.0有什么优点 增加持久性连接 也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个TCP连接，减少了建立和关闭连接的消耗和延迟。 响应头部中设置Connection: keep-alive 增加管道机制 增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。 分块传输 在 HTTP/1.1 版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 增加 host 字段 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 错误提示 HTTP/1.1 引入了一个 Warning 头域，增加对错误或警告信息的描述，此外，在 HTTP/1.1 中新增了24个状态响应码(100，101，203，205，206，301，305… )。 带宽优化 HTTP/1.1 加入了一个新的状态码 100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。 100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。 注意，HTTP/1.0 的客户端不支持 100 响应码。但可以让客户端在请求消息中加入 Expect头域，并将它的值设置为 100-continue。 5、http/2.0有哪些新特性 二进制分帧 在应用层（HTTP/2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。 可见，虽然 HTTP/2.0 的协议和 HTTP1.x 协议之间的规范完全不同了，但是实际上 HTTP/2.0并 没有改变 HTTP1.x 的语义。 简单来说，HTTP/2.0 只是把原来 HTTP1.x 的 header 和 body 部分用 frame 重新封装了一层而已。 多路复用（连接共享） 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，这个强大的功能则是基于“二进制分帧”的特性。 从图中可见，所有的 HTTP/2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。 首部压缩 HTTP1.1 不支持 header 数据的压缩，HTTP/2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 header ，减少发送包的数量从而降低延迟。 服务器推送 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，而无需客户端明确的请求。 6、简述https工作原理 6.1、https协议概念 HTTP协议：一种使用明文数据传输的网络协议。 HTTPS协议：可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密和身份认证。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。 HTTPS就是HTTP 加上数据加密处理和身份认证以及完整性校验。 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，利用对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 6.2、https工作原理 证书验证阶段 （1）浏览器发起 HTTPS 请求 浏览器里面输入一个HTTPS网址，然后连接到服务端的443端口上。注意这个过程中客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单。 （2）服务端返回 HTTPS 证书 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。 这套证书其实就是一对公钥和私钥。可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。 返回的证书还包含了很多信息，如证书的颁发机构、过期时间等等。 服务器从报文文本生成一个128位的散列值（hash值），发送方使用自己的私钥对这个散列值进行加密形成数字签名 （3）客户端验证证书是否合法，如果不合法则提示告警；验证合法则在本地生成随机数，通过公钥加密随机数，并把加密后的随机数传输到服务端 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如证书的颁发机构CA、证书的有效期、公钥、证书所有者、签名等等，如果发现异常则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，浏览器使用相同的hash算法计算出服务器发来的原始报文（证书）的hash值，再用服务器发来的公钥对证书里面的数字签名进行解密，将计算的hash值与签名做对比，对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器就可以读取证书中的公钥，用于后续加密了。 那么就生成一个随机值（会话密钥），然后用公钥对该随机值进行加密，然后返回给服务端。 注意一下上面提到的\"发现异常\"。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是\"发现异常\"，说明该证书是伪造的。 （4）服务端通过私钥对随机数（会话密钥）进行解密 服务端用私钥解密后，得到了客户端传过来的随机值（会话密钥），至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商，然后把内容通过该值进行对称加密。 数据传输阶段 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。 6.3、HTTP 和 HTTPS 的区别 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 7、TCP协议 7.1、tcp协议概念 Tcp位于传输层， 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。 即TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。所以，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。 7.2、三次握手和四次挥手 三次握手 第一次握手：建立连接时，客户端A发送SYN包（SYN，seq=x）到服务器B，并进入SYN_SEND状态，等待服务器B确认 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=x+1），同时自己也发送一个SYN包（SYN，seq=y），即SYN+ACK包，此时服务器B进入SYN_RECV状态 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，完成三次握手 四次挥手 客户端A发送一个FIN（FIN=1，seq=n），用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（ACK=n+1） 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（FIN=1，seq=m） 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（ACK=m+1） 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接**。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。先进行关闭的一方将执行主动关闭，而另一方被动关闭。 7.3、TCP和UDP区别 TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。 TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。 TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。 TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。 7.4、扩展 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有的话可能会导致最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。Server发出FIN之后，如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 MSL的定义，MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。 【问题3】为什么不能用两次握手进行连接？ 三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，可能发生死锁。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 8、什么是CDN CDN就是内容分发网络，加速网络传输，就是通过将资源部署到世界各地，用户访问时按照就近原则从最近的服务器获取资源，从而提高获取资源的速度。 CDN加速意思就是在用户和服务器之间加一个缓存机制，通过这个缓存机制可以动态的获取IP地址根据地理位置，让用户到最近的服务器访问。 CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-17 15:26:37 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 安全","keywords":"","body":"第五章 安全 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 性能","keywords":"","body":"第六章 性能 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter7/":{"url":"Chapter7/","title":"第七章 React","keywords":"","body":"第七章 React Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter8/":{"url":"Chapter8/","title":"第八章 算法","keywords":"","body":"第八章 算法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter9/":{"url":"Chapter9/","title":"第九章 数据结构","keywords":"","body":"第九章 数据结构 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter10/":{"url":"Chapter10/","title":"第十章 设计模式","keywords":"","body":"第十章 设计模式 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "},"Chapter11/":{"url":"Chapter11/","title":"第十一章 前端构建","keywords":"","body":"第十一章 前端构建 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-16 16:41:31 "}}