# 第四章 http

<!-- toc -->
- [1、http消息结构组成](#1、http消息结构组成)
- [2、列举常用的http方法并介绍get与post请求的区别](#2、列举常用的http方法并介绍get与post请求的区别)
- [3、常见的http状态码](#3、常见的http状态码)
- [4、http/1.1相比http/1.0有什么优点](#4、http11相比http10有什么优点)
- [5、http/2.0有哪些新特性](#5、http20有哪些新特性)
- [6、简述https工作原理](#6、简述https工作原理)
- [7、TCP协议](#7、TCP协议)
- [8、什么是CDN](#8、什么是CDN)
<!-- tocstop -->


## 1、http消息结构组成

HTTP消息结构组成

客户端请求消息：请求行、请求头部、请求正文

服务器响应消息：状态行、响应头、响应正文

#### **1.1、 请求报文**

- **请求行**

请求方法  URL  协议/版本 

GET www.baidu.com HTTP/1.1  

- **请求头部**

头部字段名 + 冒号（:） + 值 + 回车符 + 换行符

参考文章：[《HTTP常用头部信息》](https://www.cnblogs.com/amiezhang/p/9389840.html)

**场景：**

| RequestHeader   | 例子                                                         | 描述                                                         |
| :-------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Host            | [www.uuid.online](www.uuid.online)                           | 请求的目标域名和端口号                                       |
| Origin          | http://localhost:8081/                                       | 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息） |
| Referer         | [https:/localhost:8081/link?query=xxxxx]()                   | 请求资源的完整URI                                            |
| User-Agent      | Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 | 浏览器信息                                                   |
| Cookie          | BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0                 | 当前域名下的Cookie                                           |
| Accept          | text/html,image/png                                          | 代表客户端希望接受的数据类型是html或者是png图片类型          |
| Accept-Encoding | gzip, deflate                                                | 代表客户端能支持什么样的压缩格式                             |
| Accept-Language | zh-CN,zh;q=0.9                                               | 代表客户端可以支持语言 zh-CN 或者 zh (值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里 zh-CN 是1， zh 是0.9) |
| Connection      | keep-alive                                                   | 告诉服务器，客户端需要的 tcp 连接是一个长连接                |

- **请求正文**

一般使用在 POST 方法中， GET 方法不存在请求正文。

POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。

#### **1.2、 响应报文**

- **状态行**

协议版本 状态码 状态码描述

HTTP/1.1 200 OK

常见的状态码：

| 状态码 | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| 200    | 响应成功                                                     |
| 302    | 跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别） |
| 304    | 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存     |
| 400    | 客户端请求有语法错误，不能被服务器识别                       |
| 403    | 服务器接收到请求，但是拒绝提供服务（认证失败）               |
| 404    | 请求资源不存在                                               |
| 500    | 服务器内部错误                                               |

- **响应头部**

参考文章：[《HTTP常用头部信息》](https://www.cnblogs.com/amiezhang/p/9389840.html)

举例：

| Response Header                                 | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| Date: Mon, 30 Jul 2018 02:50:55 GMT             | 服务端发送资源时的服务器时间                                 |
| Expires: Wed, 31 Dec 1969 23:59:59 GMT          | 较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页 |
| Cache-Control: no-cache                         | 现在最多使用的控制缓存的方式，会和服务器进行缓存验           |
| etag: "fb8ba2f80b1d324bb997cbe188f28187-ssl-df" | 一般是Nginx静态服务器发来的静态文件签名，浏览在没有 “Disabled cache” 情况下，接收到 etag 后，同一个 url 第二次请求就会自动带上 “If-None-Match” |
| Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT    | 服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容 |
| Content-Type: text/html; charset=utf-8          | 如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码 |
| Content-Encoding: gzip                          | 告诉客户端，应该采用gzip对资源进行解码                       |
| Connection: keep-alive                          | 告诉客户端服务器的tcp连接也是一个长连接                      |

- **响应正文**



## 2、列举常用的http方法并介绍get与post请求的区别

#### **2.1、 http请求方法**

根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 

HTTP/1.0 定义了三种请求方法： GET, POST, PUT, DELETE和HEAD方法。 

HTTP/1.1 新增了五种请求方法：OPTIONS, TRACE和CONNECT方法。

- **get**：这种方法是将信息存储在url中，既不安全，还无法传递太大的数据。
- **post**：向指定的路径提交数据进行处理请求，一般用于表单的提交数据。

注意：数据包含在请求体中。post请求可能会导致新的资源或以有的资源被修改。

注意:这一方法可以不必传输整个响应内用的情况下，就可以获取包含在响应消息头中的原信息。

- **put**：从客户端向服务器传送的数据取代指定的文档内容。
- **delete**：请求服务器删除指定的页面
- **head**：与get请求相似的响应，但是请求体不会被返回。
- **options**：返回服务器针对特定资源所支持的http请求方法。

**options用于什么场景**

preflighted request在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出。

由于在真正访问资源前需要发送一个请求进行探测，因此该请求被称为是Preflight Request。

**【tips】**：preflighted request见第三章第3节：跨域问题

- **trace**：返回显示服务收到的请求，主要用于测试或诊断
- **connect**：http/1.1协议中预留给能够将链接改为管道方式的代理服务



#### 2.2、 get与post请求的区别

| 区别内容          | GET                                                          | POST                                                         |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 点击返回/刷新按钮 | 没有影响                                                     | 数据会重新发送（浏览器将会提示“数据被重新提交”）             |
| 缓存              | 可以                                                         | 不可以                                                       |
| 历史记录          | 有                                                           | 没有                                                         |
| 长度限制          | 有                                                           | 没有                                                         |
| 安全性            | 查询字符串会显示在地址栏的 URL 上，不安全，请不要使用 GET 请求提交敏感数据 | 因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，请使用数据加密。 |
| 可见性            | 查询字符串在地址栏的 URL 中可见                              | 查询字符串在地址栏的 URL 中不可见                            |
| 数据类型限制      | 只允许 ASCLll 字符类型                                       | 没有限制，允许二进制数据                                     |
| 添加书签          | 可以                                                         | 不可以                                                       |

**get会产生一个tcp数据包，post两个。**

具体就是：

- get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据）
- post请求时，浏览器先发送headers，服务器响应100continue，浏览器再发送data，服务器响应200（返回数据）。

这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现）



## 3、常见的http状态码

状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值:

**1xx：指示信息–表示请求已接收，继续处理。**

- 100 客户必须继续发出请求
- 101 客户要求服务器根据请求转换HTTP协议版本

**2xx：成功–表示请求已被成功接收、处理**

- 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
- 201 （已创建） 请求成功并且服务器创建了新的资源。
- 202 （已接受） 服务器已接受请求，但尚未处理。

**3xx：重定向–要完成请求必须进行更进一步的操作。**

- 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
- 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 304（使用缓存）自从上次请求后，请求的网页未修改过，请客户端使用本地缓存

**4xx：客户端错误–请求有语法错误或请求无法实现。**

- 400 （错误请求） 服务器不理解请求的语法。
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 （禁止） 服务器拒绝请求。
- 404  资源未找到

**5xx：服务器端错误–服务器未能实现合法的请求。**

- 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
- 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
- 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。



## 4、http/1.1相比http/1.0有什么优点

- **增加持久性连接**

也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个TCP连接，减少了建立和关闭连接的消耗和延迟。

**响应头部中设置Connection: keep-alive**

- **增加管道机制**

增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。

- **分块传输**

在 HTTP/1.1 版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据

发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。

- **增加 host 字段**

HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。

- **错误提示**

HTTP/1.1 引入了一个 Warning 头域，增加对错误或警告信息的描述，此外，在 HTTP/1.1 中新增了24个状态响应码(100，101，203，205，206，301，305… )。

- **带宽优化**

HTTP/1.1 加入了一个新的状态码 100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。

100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。

注意，HTTP/1.0 的客户端不支持 100 响应码。但可以让客户端在请求消息中加入 Expect头域，并将它的值设置为 100-continue。



## 5、http/2.0有哪些新特性

- **二进制分帧**

在应用层（HTTP/2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进**传输性能**，**实现低延迟**和**高吞吐量**。

可见，虽然 HTTP/2.0 的协议和 HTTP1.x 协议之间的规范完全不同了，但是实际上 HTTP/2.0并 没有改变 HTTP1.x 的语义。

简单来说，HTTP/2.0 只是把原来 HTTP1.x 的 header 和 body 部分用 frame 重新封装了一层而已。

- **多路复用（连接共享）**

允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，这个强大的功能则是基于“二进制分帧”的特性。

从图中可见，所有的 HTTP/2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。

每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。

- **首部压缩**

HTTP1.1 不支持 header 数据的压缩，HTTP/2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 header ，减少发送包的数量从而降低延迟。

- **服务器推送**

在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，而无需客户端明确的请求。

## 6、简述https工作原理

#### **6.1、https协议概念**

HTTP协议：一种使用明文数据传输的网络协议。

HTTPS协议：可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密和身份认证。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。

**HTTPS就是HTTP 加上数据加密处理和身份认证以及完整性校验。**

HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：**散列函数 、对称加密和非对称加密**。其利用**非对称加密实现身份认证和密钥协商，利用对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。**

- 内容加密：采用混合加密技术，中间者无法直接查看明文内容
- 验证身份：通过证书认证客户端访问的是自己的服务器
- 保护数据完整性：防止传输的内容被中间人冒充或者篡改

#### **6.2、https工作原理**

- **证书验证阶段**

（1）浏览器发起 HTTPS 请求

浏览器里面输入一个HTTPS网址，然后连接到服务端的443端口上。注意这个过程中客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单。

（2）服务端返回 HTTPS 证书

采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。

这套证书其实就是一对公钥和私钥。可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。

返回的证书还包含了很多信息，如证书的颁发机构、过期时间等等。

服务器从报文文本生成一个128位的散列值（hash值），发送方使用自己的私钥对这个散列值进行加密形成数字签名

（3）客户端验证证书是否合法，如果不合法则提示告警；验证合法则在本地生成随机数，通过公钥加密随机数，并把加密后的随机数传输到服务端

这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如证书的颁发机构CA、证书的有效期、公钥、证书所有者、签名等等，如果发现异常则会弹出一个警告框，提示证书存在问题。

如果证书没有问题，浏览器使用相同的hash算法计算出服务器发来的原始报文（证书）的hash值，再用服务器发来的公钥对证书里面的数字签名进行解密，将计算的hash值与签名做对比，对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器就可以读取证书中的公钥，用于后续加密了。

那么就生成一个随机值（会话密钥），然后用公钥对该随机值进行加密，然后返回给服务端。

注意一下上面提到的"发现异常"。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是"发现异常"，说明该证书是伪造的。

（4）服务端通过私钥对随机数（会话密钥）进行解密

服务端用私钥解密后，得到了客户端传过来的随机值（会话密钥），至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商，然后把内容通过该值进行对称加密。

- **数据传输阶段**

服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输

客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。

#### **6.3、HTTP 和 HTTPS 的区别**

- **https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。**
- http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。
- http 和 https 使用的是完全不同的连接方式，**用的端口也不一样，前者是80，后者是443**。
- http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。



## 7、TCP协议

#### **7.1、tcp协议概念**

Tcp位于传输层， 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。 即TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。所以，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。

#### **7.2、三次握手和四次挥手**

**三次握手**

- 第一次握手：建立连接时，客户端A发送SYN包（SYN，seq=x）到服务器B，并进入SYN_SEND状态，等待服务器B确认
- 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=x+1），同时自己也发送一个SYN包（SYN，seq=y），即SYN+ACK包，此时服务器B进入SYN_RECV状态
- 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，完成三次握手

**四次挥手**

- 客户端A发送一个FIN（FIN=1，seq=n），用来关闭客户A到服务器B的数据传送
- 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（ACK=n+1）
- 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（FIN=1，seq=m）
- 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（ACK=m+1）

**由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。**这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接**。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。先进行关闭的一方将执行主动关闭，而另一方被动关闭。

#### **7.3、TCP和UDP区别**

- TCP提供**面向连接**的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。
- TCP提供**可靠的传输**（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。
- TCP面向**字节流的传输**，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，**没有分组开销。**
- TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。

#### **7.4、扩展**

**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次挥手？**

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。

**【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有的话可能会导致最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。Server发出FIN之后，如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

MSL的定义，MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。

**【问题3】为什么不能用两次握手进行连接？**

三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

 现在把三次握手改成仅需要两次握手，可能发生死锁。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。



## 8、什么是CDN

CDN就是内容分发网络，加速网络传输，就是通过将资源部署到世界各地，用户访问时按照就近原则从最近的服务器获取资源，从而提高获取资源的速度。

CDN加速意思就是在用户和服务器之间加一个缓存机制，通过这个缓存机制可以动态的获取IP地址根据地理位置，让用户到最近的服务器访问。

CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能**就近的获取请求数据**，**解决网络拥堵，提高访问速度**，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。

