# 第1节：浏览器运行机制

<!-- toc -->

- [1、进程和线程](#1、进程和线程)
- [2、为什么JS是单线程](#2、为什么js是单线程)
- [3、单线程怎样实现异步](#3、单线程怎样实现异步)
- [4、event loop](#4、eventloop)
- [5、处理异步的几种方法](#5、处理异步的几种方法)

<!-- tocstop -->

## 1、进程和线程

#### 1.1、进程和线程

- **进程是cpu资源分配的最小单位**（是能拥有资源和独立运行的最小单位）

一个进程可以包含多个线程。

一个进程內的内存空间是共享的，每个线程都可以使用这些共享内存，一个线程使用某些共享内存时，其他线程必须等待结束后才能使用。

一个进程中至少有一个运行的主线程，进程启动后自动创建。

- **线程是cpu调度的最小单位**

**----单线程：**

优点：顺序编程简单易懂

缺点：效率低

**----多线程：**

优点：有效提升cpu利用率

缺点：

1. 线程间切换开销

对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时，多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。

2. 线程的死锁

即较长时间的等待或资源竞争以及死锁等多线程症状。

3. 访问临界资源（不同线程可共享的数据）

多个线程同时对共享数据（临界资源）进行操作时往往会发生不可预知的情况，当临界资源的操作是非原子性时，在不同的机器上，中断时间的不确定性，会导致数据在一个线程内的操作产生错误，从而产生莫名其妙的错误，而这种错误是程序员无法预知的。

#### 1.2、**浏览器是多进程的**

- 浏览器是多进程的
- 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存）
- 每打开一个Tab页，就相当于创建了一个独立的浏览器进程

> 注意：浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的）。

#### 1.3、**浏览器的内核机制**

**一个浏览器一般包括以下进程：**

- Browser进程：浏览器的主进程（负责协调、主控），只有一个
- 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
- GPU进程：最多一个，用于3D绘制
- 浏览器渲染进程（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程）

**每一个tab页面可以看作是一个浏览器内核进程，这个进程是多线程的，它有几大类子线程：**

- js引擎线程：是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。
- GUI渲染线程：负责渲染浏览器界面，解析html、css，构建dom树

当界面需要重排、重绘或由于某种操作引发回流时，该线程就会执行。

但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。

- 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
- 定时器触发线程
- 异步http请求线程



## 2、为什么js是单线程

JavaScript的单线程，与它的用途有关。

引用阮一峰老师的解答：

> 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
>
> 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。

为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，**但是子线程完全受主线程控制，且不得操作DOM**。所以，这个新标准并没有改变JavaScript单线程的本质。



## 3、单线程怎样实现异步

单线程就意味着，浏览器只分配给js一个主线程用来执行任务（函数）。

**同步任务**：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，这类任务被称作同步任务。

但前端的某些任务是非常耗时的，比如**网络请求，定时器和事件监听**，如果前一个任务耗时很长，后一个任务就不得不一直等着。这样执行效率会很低，甚至导致页面的假死。

因此，我们需要异步任务来解决这个难题。

**异步任务**：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。

**任务队列**：是一个先进先出的事件队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。

“任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。当主线程开始执行异步任务，就是执行对应的回调函数。

JS通过这样的机制，来实现异步处理。



## 4、eventloop

#### 4.1、宏任务与微任务

所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。

**MacroTask（宏任务）**： script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见[MDN](https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FWindow%2FsetImmediate)）、I/O、UI Rendering。

**MicroTask（微任务）**：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver

且process.nextTick优先级大于promise.then。

#### 4.2、eventloop

javascript在执行时，整体script作为第一个宏任务放入主线程执行；

在执行过程中，如果遇到 macrotask（例如settimeout，I/O等），则将该 macrotask 放入 macrotask 队列，继续运行执行栈中的后续代码。

如果遇到microtask，那么将该microtask放入microtask队列，继续向下运行执行栈中的后续代码。

当执行栈中的代码全部执行完成后，从microtasks队列中取出所有的microtask放入执行栈执行。执行完毕后，再从macrotasks 队列取出下一个macrotask放入执行栈。

然后不断重复上述流程，这一过程就叫做事件循环（Event Loop）。



## 5、处理异步的几种方法

#### 5.1、回调函数callback

A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行）

```javascript
function foo(callback){//定义函数的时候将另一个函数（回调函数）作为参数传入定义的函数中
    $ajax({
        //...
        success: callback//异步操作执行完毕后，再执行该回调函数，确保回调在异步操作之后执行
    })
}
function func(result){
    //...
}
foo(func)
```

--优点：实现简单、容易理解

--缺点：

1.高耦合，维护困难，回调地狱



2.每个任务只能指定一个回调函数

3.如果几个异步操作之间并没有顺序之分，同样也要等待上一个操作执行结束再进行下一个操作。

#### 5.2、事件监听

优点：比较容易理解，可以绑定多个事件，每一个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。

缺点：每次都要手动地绑定和触发事件；并且整个程序都要变成事件驱动型，运行流程会变得不清晰。

#### 5.3、promise

> promise对象是commonJS工作组提出的一种规范，目的是为了异步编程提供统一接口

**Promise代表了一个异步操作，可以将异步对象和回调函数脱离开来，可以通过链式调用的方法去解决回调嵌套的问题。**



**promise对象有以下三个状态：**

- Fulfilled---has-resolution，reslove(成功时)，调用onFulfilled
- Rejected---has-rejection，reject(失败时)，调用Rejected
- Pending---unresolve，Pending，既不是resolve也不是reject状态，也就是Promise刚刚被创建后的初始化状态

Promise的状态只会从Pending变为Fulfilled或者Rejected，不可逆。



**promise提供以下api：**

- 构造函数

- 原型方法

--`Promise.prototype.then = function() {}`

.then为Promise实例添加状态改变时的回调函数。

.then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。

.then可以使用链式调用，原因在于：每一次执行该方法时总会返回一个Promise对象。

--`Promise.prototype.catch = function() {}`

.catch用于指定发生错误时的回调函数。

--`Promise.prototype.finally = function() {}`

.finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。

- 静态方法

--`Promise.resolve = function() {}`

.resolve方法可以使Promise对象的状态改变为成功，同时传递一个参数用于后续成功后的操作。 

--`Promise.reject = function() {}`

.reject方法可以将Promise对象的状态改变为失败，同时将错误信息传递到后续错误处理的操作。 

--`Promise.all = function() {} `

.all方法用于将多个Promise实例，包装成一个新的Promise实例。只有入参数组中所有实例的状态都变成fulfilled，状态才会变成fulfilled。

--`Promise.race = function() {}`

.race方法同样用于将多个Promise实例，包装成一个新的Promise实例。入参数组之中有一个实例率先改变状态，状态就跟着改变。

#### 5.4、async/await
async/await就是Generator函数的语法糖，他返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。

async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，但async函数自带执行器，也就是说他并不需要调用next()就可以自动执行。
