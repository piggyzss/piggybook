# 第2节：强缓存和协商缓存

<!-- toc -->

- [1、浏览器缓存](#1、浏览器缓存)
- [2、强缓存](#2、强缓存)
- [3、协商缓存](#3、协商缓存)
- [4、一些状态码](#4、一些状态码)

<!-- tocstop -->



## 1、浏览器缓存

浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。

浏览器缓存的优点有：

- 减少冗余的数据传输
- 减小服务器的负担，提升网站的性能
- 加快客户端加载网页的速度

浏览器的缓存分为强缓存和协商缓存。



当客户端请求某个资源的时候，获取缓存的流程如下：

- 浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求

- 当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源

  

## 2、强缓存

#### 2.1、强缓存概念

强缓存是利用http的返回头中的`Expires`或者`Cache-Control`两个字段来表示资源的缓存时间，他无需和服务器端进行通信。

#### 2.2、强缓存实现

- **Expires**

Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求。

该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。

- **Cache-Control**

Cache-Control也是用于资源有效期。

该字段是http1.1时出现的header信息，他的设置更细致，如果和expires同时设置的话，其优先级高于Expires

--max-age：它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒

--no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。

--no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。

--public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

--private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

**Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。**



## 3、协商缓存

#### 3.1、协商缓存概念

协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。

#### 3.2、协商缓存实现

协商缓存主要涉及到两组头部 header字段： Etag和 If-None-Match、Last-Modified和If-Modified-Since

- **响应头 Last-Modified/请求头 If-Modified-Since**

**响应头 Last-Modified：** response返回，表示为资源的最后更新时间

**请求头 If-Modified-Since：**通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源

整个流程：

--浏览器第一次访问服务器的资源时，不会携带If-Modified-Since，因为未有本地缓存。

--服务器收到请求，开始处理。响应200，http头有标签：Last-Modified（date），即服务器本地记录的文件最后修改时间。

--浏览器收到响应，缓存到本地。

--浏览器第二次请求时，携带If-Modified-Since（date）,

--服务器比较If-Modified-Since（date）,是否与服务器本地记录相同。决定返回状态200还是304.

- **响应头 Etag/请求头 If-None-Match**

**响应头 etag：**就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的

**请求头 If-None-Match：**header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来



整个流程：

--浏览器第一次请求一个资源的时候，服务端收到请求，处理响应并且返回了ETag: "50b1c1d4f775c61:df3" 这样的字样给浏览器

--当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: W/"50b1c1d4f775c61:df3" 传输给服务端，服务端拿到该etag，对比资源是否发生变化：如果资源没更改，返回304，浏览器读取本地缓存；如果资源有更改，返回200，返回最新的资源。



**ETag的优先级比Last-Modified更高**

#### 3.3、为什么需要ETag？

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器不能精确的得到文件的最后修改时间



## 4、一些状态码

- 200：强缓Expires/Cache-Control存失效时，返回新的资源文件
- 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功
- 304(Not Modified )：**协商缓存Last-modified/Etag没有过期时，服务端返回状态码304**

告诉浏览器，上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用



**【参考】**

[浏览器缓存：强缓存和协商缓存](https://www.cnblogs.com/iceflorence/p/8905825.html)

[彻底捋一捋缓存（二）——浏览器缓存机制：强缓存、协商缓存](https://juejin.im/entry/5ac95b4d51882548fe4a61e0)

