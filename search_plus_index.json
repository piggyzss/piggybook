{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 最近参加面试的过程中，将自己前端知识树重新梳立了一遍，现汇总整理如下，不仅作为自己准备面试的map，也是对以往学习内容的集中复盘和回顾。 内容主要分为Javascript、html、浏览器、http、安全、性能、React、算法、数据结构、设计模式、前端构建，后续会视情况陆续补充node、vue等内容。 如果你有好的意见或建议，请邮件联系我1158591034@qq.com。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter1/":{"url":"Chapter1/","title":"第一章 Javascript","keywords":"","body":"第一章 Javascript 第1节：基础 第2节：原理性实现 第3节：常见解决方法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-19 11:33:56 "},"Chapter1/基础.html":{"url":"Chapter1/基础.html","title":"第1节：基础","keywords":"","body":"第1节： 基础 1、数据类型 2、执行上下文 3、this 4、作用域和作用域链 5、闭包 6、原型 7、继承 1、数据类型 1.1、数据类型 基本类型：Number，String，Boolean，Symbol，Undefined，Null 引用类型：Object，Array，Function 1.2、数据类型判断 typeof typeof 返回的是字符串，有六种可能： \"number\"、\"string\"、\"boolean\"、\"object\"、\"function\"、\"undefined\" typeof null --> \"object\" typeof [1,2,3] --> \"object\" typeof NaN --> \"number\" Object.prototype.toString.call 利用object的原型方法toString能返回相应的类型： Object.prototype.toString.call(123) // \"[object Number]\" Object.prototype.toString.call('') // \"[object String]\" Object.prototype.toString.call(true) // \"[object Boolean] Object.prototype.toString.call(Symbol()) // \"[object Symbol]\" Object.prototype.toString.call(null) // \"[object Null]\" Object.prototype.toString.call(undefined) // \"[object Undefined]\" Object.prototype.toString.call({a:1}) // \"[object Object]\" Object.prototype.toString.call([1,2]) // \"[object Array]\" Object.prototype.toString.call(function(){}) // \"[object Function]\" instanceof 判断构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。 [1,2] instanceof Array // true (function(){}) instanceof Function // true ({a:1}) instanceof Object // true constructor (2).constructor === Number // true (true).constructor === Boolean // true ('str').constructor === String // true ([]).constructor === Array // true (function() {}).constructor === Function // true ({}).constructor === Object // true 1.3、隐式类型转换 1.对象和字符串进行比较时，对象转换为字符串，然后两者进行比较 [1,2,3] == '1,2,3' // true，[1,2,3] 转化为 '1,2,3' 2.对象和数字比较时，对象转化为字符串,然后转换为数字，再和数字进行比较 [1] == 1 // true，[1]转换为'1'再转换为1 3.对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字 [] == false // true，[]转换为字符串'',然后再转换为数字0，false转换为数字0 4.字符串和数字比较时，字符串转换为数字 '1' == 1 5.布尔值和数字进行比较时，布尔转换为数字 true == 1 6.字符串和布尔值进行比较时，二者全部转换成数值再比较 '1' == true 总结： 对象 | 字符串 布尔 | | 数值 2、执行上下文 执行上下文包括全局执行上下文、函数执行上下文、eval 执行上下文 执行上下文(执行上下文环境)实际上是做以下准备工作： 变量、函数表达式——变量声明，默认赋值为undefined this——赋值 函数声明——赋值 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中(入栈)；程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出(出栈)，控制权交由下一个执行上下文。 因为JS执行中最先进入全局环境，所以处于\"栈底的永远是全局环境的执行上下文\"。而处于\"栈顶的是当前正在执行函数的执行上下文\"，当函数调用完成后，它就会从栈顶被推出。 因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈称为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 3、this 3.1、this是什么 this的作用就是在函数体内部获取当前的运行环境。 3.2、this 的四种绑定规则 this绑定规则有：默认绑定、隐式绑定、显示绑定、new 绑定 默认绑定 在没有其他绑定规则时，或者说当只有一个独立函数被调用时，this指向的是window对象。 在严格模式下（\"use strict\";），全局对象将无法使用默认绑定，即执行会报undefined的错误。 隐式绑定 函数是作为某个对象的方法调用的，即调用位置上存在上下文对象。 this进行了隐式绑定，即this绑定到了对象obj上 显式绑定 显式绑定就是通过apply，call，bind，直接将函数中的this绑定到想要的对象上 显式绑定主要是通过改变对象的proto关联对象 new 绑定 使用new操作符，可以将函数的this指向新创建的对象。 3.3、优先级 判断this绑定的顺序： （1）判断是否是new调用，是的话就是new绑定，函数中的this会指向新构造的对象。 （2）判断是否是显示绑定，即是否是通过函数原型中的apply方法或者call方法调用 （还要注意bind返回的函数，this指向也会被修改）。 （3）判断是否是隐式绑定，及通过某个对象调用。是的话，this会指向所属对象。 （4）如果都没有的话，就是默认绑定，this指向全局对象window；严格模式下指向undefined。 总结：new绑定 > 显式绑定 >隐式绑定 > 默认绑定 3.4、箭头函数 通过“=>”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。 简单来说，就是捕获函数定义位置作用域的 this，作为自己函数内部的 this。 箭头函数在定义时就绑定了this，而非取决于调用位置，同样用call、apply、bind都无法更改this。 4、作用域和作用域链 作用域 作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。 --全局作用域：没有在函数内声明或未通过var声明的变量。 --局部作用域：JS没有块级作用域，只有函数级作用域，变量在声明它们的函数体内及其子函数內都是可见的。 tips：ES6之后，可以通过let/const声明块级作用域的变量。 作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境有权访问的变量和函数的有序访问。 当一个变量在当前作用域下找不到该变量定义，那么JS引擎会沿着作用链往上查找。 具体来说：就是把函数自身的本地变量放在最前面，把父级函数的变量放在其次，把再高一级函数中的变量放在更后面，以此类推直到全局变量为止。 函数作用域可以通过作用域链访问到外部甚至全局的变量，而外部想要访问内部的变量或函数，则需要通过闭包。 5、闭包 5.1、闭包概念 定义：函数访问了上层作用域的变量，并且在当前作用域之外执行，就会形成闭包 判定准则：执行时是否在内部定义的函数中访问了上层作用域的变量。 函数与创建该函数的词法环境（lexical environment）共同构成闭包（closure）。这个环境指的是函数创建时，它可以访问的所有变量。 function init() { var name = \"Hello\"; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 } return displayName(); // 闭包被返回 } var fun = init(); fun(); 通过这个返回的闭包，我们就可以访问这个函数所相关联的词法环境或者说数据。本来应该被销毁的 name 变量保留了下来。 5.2、【经典面试题目】 for (var i=1; i 因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法： for (var i=1; i （1）闭包 for (var i = 1; i （2）使用 setTimeout 的第三个参数 for ( var i=1; i （3）使用 let 定义 i for (let i=1; i 扩展 setTimeout有三个参数：参数一为一个函数，我们通过该函数定义将要执行的操作；参数二为一个时间毫秒数，表示延迟执行的时间；参数三是给setTimeout第一个函数的参数。 每一个setTimeout在执行时，会返回一个唯一ID，唯一ID保存起来用以传入clearTimeout来清除定时器。 5.3、闭包的应用 数据隐藏和封装 var counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } }; })(); 可以通过一个匿名的立即执行的函数来创建一个共享的环境空间，环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。只有通过匿名包装器返回的属性或方法数才能被外界访问，这样就达到了数据的隐藏封装，不污染全局环境的目的。 使用闭包设计单例模式 class CreateUser { constructor(name) { this.name = name; this.getName(); } getName() { return this.name; } } // 代理实现单例模式 var ProxyMode = (function() { var instance = null; return function(name) { if(!instance) { instance = new CreateUser(name); } return instance; } })(); // 测试单体模式的实例 var a = ProxyMode(\"aaa\"); var b = ProxyMode(\"bbb\"); // 因为单体模式是只实例化一次，所以下面的实例是相等的 console.log(a === b); //true 5.4、闭包缺点 闭包会对脚本性能具有负面影响，包括处理速度和内存消耗。 6、原型 prototype 每个函数都有 prototype 属性(除了 Function.prototype.bind())，这个属性是一个指针，指向一个对象，这个对象包含可以由这个函数new出的所有实例共享的属性和方法。这是一个显式原型属性，只有函数才拥有该属性。 proto 每个对象都有 proto属性，指向了创建该对象的构造函数的原型(也就是构造函数的prototype)。这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。 因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 proto 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。 当我们使用 new 操作符时，实际上就是使生成的实例对象的proto_属性指向对应构造函数的prototype。 7、继承 7.1、ES5继承方式 在ES6之前，继承的实现方式主要有以下几种：原型链继承、构造继承、组合继承、寄生组合继承。 原型链继承 将父类的实例作为子类的原型 function Parent () { this.name = 'kevin' } Parent.prototype.getName = function () { console.log(this.name) } function Child () {} Child.prototype = new Parent() var child = new Child() 缺点： 1.引用类型的属性被所有实例共享 2.在创建子类的实例时，不能向父类传参 构造继承 使用父类的构造函数来增强子类实例 function Parent () { this.name = 'kevin' } Parent.prototype.getName = function () { console.log(this.name) } function Child () {} Child.prototype = new Parent() var child = new Child() 组合继承 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 缺点：会调用两次父构造函数，一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候 寄生组合继承 function parent(name){ } parent.prototype.getName = function(){ } function child(name){ parent.call(this,name) } //重要 function F(){} F.prototype = parent.prototype child.prototype = new F() 7.2、class class是ES6中引入的继承机制，他实际是Javascript关于原型继承机制的语法糖，本质上是对原型继承的封装。 extends关键字 把子类实例child的原型对象(Child.prototype) 的原型(proto)指向了父类parent的原型对象(Parent.prototype)。 把子类构造函数(Child)的原型(proto)指向了父类构造函数(Parent)。 function _extends(Child, Parent){ Child.prototype.__proto__= Parent.prototype Child.prototype.constructor = Child // Object.setPrototypeOf(), 为现有对象设置原型 // 等价于Child.__proto__ = Parent Object.setPrototypeOf(Child, Parent) } super关键字 子类构造函数继承了父类构造函数的属性，通过调用super实现(ES5则用call或者apply调用传参，个人理解实际上就是完成了构造继承的这部分)。 子类继承父类时，子类没有定义constrcutor，则会默认添加一个constrcutor，并且在constrcutor中调用super，相当于调用父类的构造函数。 子类必须在constructor方法中调用super方法，否则new实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象。如果不调用super函数，子类就得不到this对象。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter1/原理性实现.html":{"url":"Chapter1/原理性实现.html","title":"第2节：原理性实现","keywords":"","body":"第2节： 原理性实现 1、debounce 2、throttle 3、bind、call、apply 4、实现instanceof 5、实现柯里化函数 6、实现compose和pipe 7、实现new 1、debounce 防抖的原理是：在事件被触发后不马上执行回调，n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 function debounce(func: Function, wait = 500) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer: any = null return function(...args: any[]) { timer && clearTimeout(timer) timer = setTimeout(() => { func(...args) }, wait) } } 2、throttle 节流的原理是：让一个函数不要执行得太频繁，减少一些过快的函数调用来节流。也就是在一段固定的时间内只触发一次回调函数 时间戳版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } // 第一次先打一个初始时间戳设置为0 var previous = 0 return function () { // 通过date.now取到当前时间，二者相减如果大于时间间隔，则调用传入的func，并且把时间戳previous设置为now var now = Date.now() if (now - previous > wait) { func.apply(this, [...arguments]) previous = now } } } 定时器版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer = null return function() { // 如果判断出定时器timer为空，则会起定时器赋值给timer，定时器的回调处理函数中调用传入的func，并且清空定时器 if (!timer) { timer = setTimeout(function(){ timer = null func.apply(this, [...arguments]) }, wait) } } } 3、bind、call、apply call Function.prototype.Call = function (context) { var context = context || window // 给 context 添加一个属性 context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.Apply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind Function.prototype.Bind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { var context = context || window context.fn = this var result if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } } 4、实现instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 5、实现柯里化函数 function curry(fn) { var _this = this return function inner(...args) { // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (**args.length inner.call(_this, ...args, ...innerArgs)** } // 参数收集完毕，则执行fn return fn.apply(this, args) } } 扩展题目 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add() { var _args = [...arguments] return function() { if (arguments.length === 0) { return _args.reduce(function (a, b) { return a + b }) } [].push.apply(_args, [...arguments]) return arguments.callee } } add(1, 2)(1)(2)(5)() 6、实现compose和pipe 实现函数compose，compose接受多个函数作为参数，并返回一个新的函数，新的函数会从右向左依次执行原函数， 并且上一次结果的返回值将会作为下一个函数的参数。 function compose(...fns) { return (...args) => fns.reduceRight((acc, cur) => cur(acc), ...args); } compose 的数据流是从右至左的，因为最右侧的函数首先执行，将数据 传递给下一个函数，以此类推 ...... 最左侧的函数最后执行；而管道的数据流是 从左至右的。 实现一个管道函数： const pipe = (...fns) => (...args) => fns.reduce((acc, cur) => cb(cur) , args) 7、实现new 创建一个空的新对象 新对象的proto属性指向构造函数的原型对象 绑定this，执行构造函数 返回新对象 function create () { let obj = new Object() let constructor = [].shift.apply(arguments) obj.__proto__ = constructor.prototype let result = constructor.apply(obj, arguments) return typeof result === \"object\" ? result : obj } 8、实现Promise 规范 Promise规范有很多，如Promise/A，Promise/B，Promise/D以及 Promise/A的升级版 Promise/A+。ES6中采用了 Promise/A+规范。 英文版规范: Promises/A+规范 中文版规范: Promises/A+规范(中文) Promise标准解读 (1) 一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。 (2) promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then方法可以被同一个 promise调用多次。 Promise实现 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-19 11:31:08 "},"Chapter1/常见解决方法.html":{"url":"Chapter1/常见解决方法.html","title":"第3节：常见解决方法","keywords":"","body":"第3节：常见解决方法 1、深拷贝 2、实现一个ajax 3、数组去重 4、周期性执行一个函数n次 5、基于promise实现重试功能 6、实现一个休眠函数 1、深拷贝 function deepCopy(src){ if (!src | !(src instanceof Object) | (typeof src === \"function\")) { return src || undefined } var constructor = src.constructor var dst = new constructor() for (var key in src) { if (src.hasOwnProperty(key)) { dst[key] = deepCopy(src[key]) } } return dst } 2、实现一个ajax function getData(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onreadystatechange = handler; xhr.responseType = \"json\"; xhr.setRequestHeader(\"Accept\", \"application/json\"); xhr.send(); }); return promise; }; 3、数组去重 set去重 [...(new set([]))] 基本数组去重 Array.prototype.unique = function() { var result = [] this.forEach((val) => { if(result.indexOf(val) 利用hash表去重，空间换时间 ** Array.prototype.unique = function() { var hash = {} var result = [] this.forEach((val) => { if(!hash[val]) { obj[val] = true result.push(val) } }) return result } 4、周期性执行一个函数n次 function circlExe(fn, wait=0, num=0){ var count = 0 function inner() { if(count >= num) { return } count++ setTimeout(() => { inner.call(this, ...arguments) fn.call(this, ...arguments) }, wait) } return inner } 5、基于promise实现重试功能 function getData(delay){ return new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num 打印结果： 随机数生成的值： 17 还有 5 次尝试 随机数生成的值： 15 还有 4 次尝试 随机数生成的值： 16 还有 3 次尝试 随机数生成的值： 20 还有 2 次尝试 随机数生成的值： 16 还有 1 次尝试 随机数生成的值： 15 还有 0 次尝试 6、实现一个休眠函数 封装一个休眠函数，入参是定时器的等待时间，.then执行回调函数 function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter2/":{"url":"Chapter2/","title":"第二章 HTML & CSS","keywords":"","body":"第二章 HTML & CSS 第1节：HTML 第2节：CSS Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 16:49:33 "},"Chapter2/HTML.html":{"url":"Chapter2/HTML.html","title":"第1节：HTML","keywords":"","body":"第1节：HTML 1、html语义化的理解 2、script标签 3、协商缓存 4、一些状态码 1、html语义化的理解 用合理、正确的标签展示内容 语义化可以使页面内容结构更清晰，在没有css样式的情况下，也会以一种文档的格式显示，并且是容易阅读的 搜索引擎的爬虫也依赖于HTML标记确定上下文和各个关键字的权重，利于seo 更易理解维护，比如头部、、页面导航、侧边栏、分组内容 2、script标签 defer：只适用于外部脚本文件。脚本会立即下载，但是会延迟到整个页面全部加载完毕之后再运行。defer多个脚本是按照顺序执行的，如果有依赖关系，需要特别注意脚本顺序。 async：同样只适用于外部脚本。浏览器立即下载脚本，但是下载完毕之后立即执行，运行的同时并不阻止浏览器去解析下面的内容。使用async主要是脚本下载时并不影响页面的渲染。多个async脚本之间不能保证运行顺序 如果不使用 async 且 defer=“defer”：脚本将在页面完成解析时执行，因为defer表示脚本下载完并不执行而是等页面全部加载完之后再执行。 如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本。 charset：规定在外部脚本文件中使用的字符编码 type src：规定外部脚本文件的 URL Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 19:35:29 "},"Chapter2/CSS.html":{"url":"Chapter2/CSS.html","title":"第2节：CSS","keywords":"","body":"第2节：CSS 1、盒模型 2、BFC 3、清除浮动 4、定位机制 5、水平居中/垂直居中 6、flex布局 7、实现一个两边宽度固定中间自适应的三列布局 1、盒模型 盒模型:content、padding、border、margin 标准模型 box-sizing:content-box IE模型 box-sizing:border-box div{ height: 100px; width: 100px; border: 10px solid red; padding: 10px; box-sizing:content-box; 实际大小为140px*140px; box-sizing:border-box; 实际大小为100px*100px; } 2、BFC BFC(Block Formatting Context , 块级格式化上下文) BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 官方定义： 浮动元素、绝对定位元素、不是块级盒的包含块（比如inline-block、tabel-cell、tabel-captain）、和overflow值不为visible的块级盒子为他们的内容建立了一个新的块级排版上下文 在一个BFC中，盒子是从包含块顶部开始放置的，他们会在垂直方向一个接一个的排列 盒子垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算 怎么取创建BFC float属性不为none（脱离文档流） position为absolute或fixed display为inline-block、table-cell、table-caption、flex、inine-flex overflow不为visible 3、清除浮动 3.1、浮动产生的问题 不清除浮动，浮动层后面跟随的非浮动内容就有可能被浮动层所覆盖，造成版面混乱 在文档流中，父元素的高度未设置时，默认是被子元素撑开的，也就是说子元素多高，父元素就多高。但当子元素被设置浮动之后，它会完全脱离文档流，此时会导致子元素无法撑起父元素的高度，从而导致父元素的高度塌陷。 3.2、解决浮动的方法 增加一个空标签 .div1{border:1px solid red} .left{float:left; width:20%; height:200px;} .right{float:right; width:30%; height:80px;} /*清除浮动代码*/ .clearfloat{clear:both} Left Right 优点：浏览器支持好 缺点：增加了无意义的空标签 利用br标签 优点：比空标签方式语义稍强 缺点：有悖结构与表现分离的原理 父元素overflow:auto或overflow:hidden 优点：不存在结构和语义化问题 缺点：内容超出父级元素时，auto会产生滚动条，hidden会隐藏部分内容 伪元素 .parent{border:1px solid red} .parent:after{ content:\"\"; display:block; clear:both; } 优点：结构和语义化完全正确 4、定位机制 position有四个属性值：static、relative、absolute、fixed static position的默认值，按照正常的文档流进行排列。 当元素未定义position或定义position值为static时，该元素内定义的top, bottom, left, right 和 z-index无效。 relative 相对定位，按照正常的文档流进行排列，相对于元素在文档流中的位置进行偏移，会依据top，right，bottom，left等属性在正常文档流中偏移位置。 absolute 绝对定位，脱离正常文档流，不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。 绝对定位之后，标签就不再区分行内元素和块级元素了，可以设置宽高（无需display）。 fixed 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。 5、水平居中/垂直居中 5.1、水平居中 行内元素：设置text-align: center 块级元素：margin: 0 auto 5.2、垂直居中 行内元素：设置line-height：height 块级元素：利用tabel属性 #parent{ display: table; } #child{ display: table-cell; } /**center code**/ vertical-align: middle; /**center code**/ 在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式 5.3、块级元素水平垂直均居中 利用flex display: flex; flex-direction: column; justify-content: center; align-items: center; 利用定位 #parent{ position: relative; } #child{ width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); // margin:-50px 0 0 -50px; } 或 #parent{ position:relative; } #child{ position:absolute; margin:auto; top:0; bottom:0; left:0; right:0; } 6、flex布局 6.1、flex布局 flex布局即弹性盒布局，用来为盒状模型提供最大的灵活性。 设为 flex 布局以后，子元素的float、clear和vertical-align属性将失效。 6.2、容器元素属性 flex-direction：row | row-reverse | column | column-reverse // 子元素的主轴方向 flex-wrap：nowrap | wrap | wrap-reverse // 换行方式 flex-flow： flex-direction || flex-wrap justify-content：flex-start | flex-end | center | space-between | space-around // 主轴的对齐方式 align-items：flex-start | flex-end | center | baseline | stretch // 交叉轴上如何对齐 align-content：flex-start | flex-end | center | space-between | space-around | stretch //多根轴线的对齐方式 6.3、子元素属性 order：num // 排列顺序 flex-grow：num // 放大比例，默认为0，即如果存在剩余空间，也不放大 flex-shrink：num // 缩小比例，默认为1，即如果空间不足，该项目将缩小，如果为0，其他项目都为1，则空间不足时，前者不缩小 flex-basis：length // 在分配多余空间之前，项目占据的主轴空间（main size），默认值为auto，即项目的本来大小 flex：flex-grow flex-shrink flex-basis // 0 1 auto .item { flex: 1; } 等同于 .item { flex-grow: 1; flex-shrink: 1; flex-basis: 0%; } align-self：auto | flex-start | flex-end | center | baseline | stretch // align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 【Tips】 对于flex-basis的说明 这个属性决定CSS如何给可伸缩项在容器中分配初始大小（为简化讨论，以下一律假定“大小”为宽度，高度与之类似）。以下是这个属性几种常用的值： auto（默认值）：auto的意思是首先看当前项有没有明确设置宽度，如果有则使用该宽度；如果没有，则以包含的内容决定宽度。 content：content是不管当前项是否明确设置了宽度，一律以内容决定宽度 长度或百分比值：百分比是相对于容器而言的。知道了每一项的宽度，简单相加就能得到所有项宽度的总和。而知道了所有项宽度的总和，再与容器宽度比较，就能知道容器里是不是还有剩余空间可供再次分配。 Flex Items的应用准则：content –> width –> flex-basis 也就是说： 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 **如果同时设置了flex-basis属性和width属性，那么以flex-basis为准 7、实现一个两边宽度固定中间自适应的三列布局 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 19:54:49 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 浏览器","keywords":"","body":"第三章 浏览器 第1节：浏览器运行机制 第2节：强缓存和协商缓存 第3节：跨域问题 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-19 11:34:58 "},"Chapter3/浏览器运行机制.html":{"url":"Chapter3/浏览器运行机制.html","title":"第1节：浏览器运行机制","keywords":"","body":"第1节：浏览器运行机制 1、进程和线程 2、为什么JS是单线程 3、单线程怎样实现异步 4、event loop 5、处理异步的几种方法 1、进程和线程 1.1、进程和线程 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 一个进程可以包含多个线程。 一个进程內的内存空间是共享的，每个线程都可以使用这些共享内存，一个线程使用某些共享内存时，其他线程必须等待结束后才能使用。 一个进程中至少有一个运行的主线程，进程启动后自动创建。 线程是cpu调度的最小单位 ----单线程： 优点：顺序编程简单易懂 缺点：效率低 ----多线程： 优点：有效提升cpu利用率 缺点： 线程间切换开销 对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时，多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。 线程的死锁 即较长时间的等待或资源竞争以及死锁等多线程症状。 访问临界资源（不同线程可共享的数据） 多个线程同时对共享数据（临界资源）进行操作时往往会发生不可预知的情况，当临界资源的操作是非原子性时，在不同的机器上，中断时间的不确定性，会导致数据在一个线程内的操作产生错误，从而产生莫名其妙的错误，而这种错误是程序员无法预知的。 1.2、浏览器是多进程的 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 每打开一个Tab页，就相当于创建了一个独立的浏览器进程 注意：浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的）。 1.3、浏览器的内核机制 一个浏览器一般包括以下进程： Browser进程：浏览器的主进程（负责协调、主控），只有一个 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制 浏览器渲染进程（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程） 每一个tab页面可以看作是一个浏览器内核进程，这个进程是多线程的，它有几大类子线程： js引擎线程：是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。 GUI渲染线程：负责渲染浏览器界面，解析html、css，构建dom树 当界面需要重排、重绘或由于某种操作引发回流时，该线程就会执行。 但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 定时器触发线程 异步http请求线程 2、为什么js是单线程 JavaScript的单线程，与它的用途有关。 引用阮一峰老师的解答： 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 3、单线程怎样实现异步 单线程就意味着，浏览器只分配给js一个主线程用来执行任务（函数）。 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，这类任务被称作同步任务。 但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果前一个任务耗时很长，后一个任务就不得不一直等着。这样执行效率会很低，甚至导致页面的假死。 因此，我们需要异步任务来解决这个难题。 异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 任务队列：是一个先进先出的事件队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。当主线程开始执行异步任务，就是执行对应的回调函数。 JS通过这样的机制，来实现异步处理。 4、eventloop 4.1、宏任务与微任务 所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。 MacroTask（宏任务）： script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务）：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver 且process.nextTick优先级大于promise.then。 4.2、eventloop javascript在执行时，整体script作为第一个宏任务放入主线程执行； 在执行过程中，如果遇到 macrotask（例如settimeout，I/O等），则将该 macrotask 放入 macrotask 队列，继续运行执行栈中的后续代码。 如果遇到microtask，那么将该microtask放入microtask队列，继续向下运行执行栈中的后续代码。 当执行栈中的代码全部执行完成后，从microtasks队列中取出所有的microtask放入执行栈执行。执行完毕后，再从macrotasks 队列取出下一个macrotask放入执行栈。 然后不断重复上述流程，这一过程就叫做事件循环（Event Loop）。 5、处理异步的几种方法 5.1、回调函数callback A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行） function foo(callback){//定义函数的时候将另一个函数（回调函数）作为参数传入定义的函数中 $ajax({ //... success: callback//异步操作执行完毕后，再执行该回调函数，确保回调在异步操作之后执行 }) } function func(result){ //... } foo(func) --优点：实现简单、容易理解 --缺点： 1.高耦合，维护困难，回调地狱 2.每个任务只能指定一个回调函数 3.如果几个异步操作之间并没有顺序之分，同样也要等待上一个操作执行结束再进行下一个操作。 5.2、事件监听 优点：比较容易理解，可以绑定多个事件，每一个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。 缺点：每次都要手动地绑定和触发事件；并且整个程序都要变成事件驱动型，运行流程会变得不清晰。 5.3、promise promise对象是commonJS工作组提出的一种规范，目的是为了异步编程提供统一接口 Promise代表了一个异步操作，可以将异步对象和回调函数脱离开来，可以通过链式调用的方法去解决回调嵌套的问题。 promise对象有以下三个状态： Fulfilled---has-resolution，reslove(成功时)，调用onFulfilled Rejected---has-rejection，reject(失败时)，调用Rejected Pending---unresolve，Pending，既不是resolve也不是reject状态，也就是Promise刚刚被创建后的初始化状态 Promise的状态只会从Pending变为Fulfilled或者Rejected，不可逆。 promise提供以下api： 构造函数 原型方法 --Promise.prototype.then = function() {} .then为Promise实例添加状态改变时的回调函数。 .then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。 .then可以使用链式调用，原因在于：每一次执行该方法时总会返回一个Promise对象。 --Promise.prototype.catch = function() {} .catch用于指定发生错误时的回调函数。 --Promise.prototype.finally = function() {} .finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 静态方法 --Promise.resolve = function() {} .resolve方法可以使Promise对象的状态改变为成功，同时传递一个参数用于后续成功后的操作。 --Promise.reject = function() {} .reject方法可以将Promise对象的状态改变为失败，同时将错误信息传递到后续错误处理的操作。 --Promise.all = function() {} .all方法用于将多个Promise实例，包装成一个新的Promise实例。只有入参数组中所有实例的状态都变成fulfilled，状态才会变成fulfilled。 --Promise.race = function() {} .race方法同样用于将多个Promise实例，包装成一个新的Promise实例。入参数组之中有一个实例率先改变状态，状态就跟着改变。 5.4、async/await async/await就是Generator函数的语法糖，他返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，但async函数自带执行器，也就是说他并不需要调用next()就可以自动执行。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 16:41:13 "},"Chapter3/强缓存和协商缓存.html":{"url":"Chapter3/强缓存和协商缓存.html","title":"第2节：强缓存和协商缓存","keywords":"","body":"第2节：强缓存和协商缓存 1、浏览器缓存 2、强缓存 3、协商缓存 4、一些状态码 1、浏览器缓存 浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有： 减少冗余的数据传输 减小服务器的负担，提升网站的性能 加快客户端加载网页的速度 浏览器的缓存分为强缓存和协商缓存。 当客户端请求某个资源的时候，获取缓存的流程如下： 浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求 当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源 2、强缓存 2.1、强缓存概念 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来表示资源的缓存时间，他无需和服务器端进行通信。 2.2、强缓存实现 Expires Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求。 该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control Cache-Control也是用于资源有效期。 该字段是http1.1时出现的header信息，他的设置更细致，如果和expires同时设置的话，其优先级高于Expires --max-age：它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒 --no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 --no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 --public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 --private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 3、协商缓存 3.1、协商缓存概念 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 3.2、协商缓存实现 协商缓存主要涉及到两组头部 header字段： Etag和 If-None-Match、Last-Modified和If-Modified-Since 响应头 Last-Modified/请求头 If-Modified-Since 响应头 Last-Modified： response返回，表示为资源的最后更新时间 请求头 If-Modified-Since：通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源 整个流程： --浏览器第一次访问服务器的资源时，不会携带If-Modified-Since，因为未有本地缓存。 --服务器收到请求，开始处理。响应200，http头有标签：Last-Modified（date），即服务器本地记录的文件最后修改时间。 --浏览器收到响应，缓存到本地。 --浏览器第二次请求时，携带If-Modified-Since（date）, --服务器比较If-Modified-Since（date）,是否与服务器本地记录相同。决定返回状态200还是304. 响应头 Etag/请求头 If-None-Match 响应头 etag：就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 请求头 If-None-Match：header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来 整个流程： --浏览器第一次请求一个资源的时候，服务端收到请求，处理响应并且返回了ETag: \"50b1c1d4f775c61:df3\" 这样的字样给浏览器 --当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: W/\"50b1c1d4f775c61:df3\" 传输给服务端，服务端拿到该etag，对比资源是否发生变化：如果资源没更改，返回304，浏览器读取本地缓存；如果资源有更改，返回200，返回最新的资源。 ETag的优先级比Last-Modified更高 3.3、为什么需要ETag？ 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间 4、一些状态码 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 告诉浏览器，上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 【参考】 浏览器缓存：强缓存和协商缓存 彻底捋一捋缓存（二）——浏览器缓存机制：强缓存、协商缓存 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 15:09:50 "},"Chapter3/跨域问题.html":{"url":"Chapter3/跨域问题.html","title":"第3节：跨域问题","keywords":"","body":"第3节：跨域问题 1、浏览器同源策略 2、什么是跨域问题 3、跨域的解决方案 4、canvas操作图片的跨域问题 1、浏览器同源策略 如果两个页面的协议，主机（域名）、端口都相同，则两个页面具有相同的源。 同源策略限制了以下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 2、什么是跨域问题 跨域是指一个域下的文档或脚本试图请求另一个域下的资源。 广义的跨域包括： 资源跳转：a链接、重定向、表单提交 资源嵌入：、、、等标签，还有background：url()、@font-face等文档外链 脚本请求：js发起的ajax请求，dom和js对象的跨域操作 通常所说的跨域是狭义的：是由浏览器同源策略限制的一类请求场景 3、跨域的解决方案 3.1、JSONP（JSON with padding） 概念 利用 script 标签没有跨域限制的策略，通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据，从而实现跨域访问。 最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。 核心思想：网页通过添加一个元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 实现 JSONP由两部分组成：回调函数和数据 回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数的JSON数据 客户端： let script = document.createElement('script'); script.src = 'http://localhost:1234/article-list?name=leo&age=30&callback=func'; // 向服务器发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字 document.body.appendChild(script); // 处理服务器返回回调函数的数据 function func(res) { console.log(res); } 服务端（node）： router.get('/article-list', (req, res) => { let data = { message: 'success!', name: req.query.name, age: req.query.age } data = JSON.stringify(data) res.end(`func(${data})`); }) 实际上拥有src属性的标签都可以跨域，比如 3.2、CORS（跨域资源共享） 它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。 CORS则将导致跨域访问的请求分为三种：Simple Request，Preflighted Request以及Requests with Credential。 3.2.1、 Simple Request（简单跨域请求） 如果一个请求没有包含任何自定义请求头，而且它所使用HTTP动词是HEAD，GET或POST之一，那么它就是一个Simple Request。但是在使用POST作为请求的动词时，该请求的Content-Type需要是application/x-www-form-urlencoded，multipart/form-data或text/plain之一。 解决方法： 假设ambergarden.com想从一个公有数据平台public-data.com中返回一些数据，那么在页面逻辑中，其可以通过下面的代码向public-data.com发送数据请求： function retrieveData() { var request = new XMLHttpRequest() request.open('GET', 'http://public-data.com/someData', true) request.onreadystatechange = handler request.send() } 在运行这段代码的之后，浏览器会向服务端发送如下的请求： GET /someData/ HTTP/1.1 Host: public-data.com ...... Referer: http://ambergarden.com/somePage.html Origin: http://ambergarden.com 服务端设置通过设置Access-Control-Allow-Origin，来支持跨域。 该响应头用来记录可以访问该资源的域。在接收到服务端响应后，浏览器将会查看响应中是否包含Access-Control-Allow-Origin响应头。如果该响应头存在，那么浏览器会分析该响应头中所标示的内容。如果其包含了当前页面所在的域，那么浏览器就将知道这是一个被允许的跨域访问，从而不再根据Same-origin Policy来限制用户对该数据的访问。 然后服务端给出如下响应： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://ambergarden.com Content-Type: application/xml ...... 3.2.2、 Preflighted Request（带预检的跨域请求） 如果一个请求包含了任何自定义请求头，或者它所使用的HTTP动词是GET，HEAD或POST之外的任何一个动词，那么它就是一个Preflighted Request。如果POST请求的Content-Type并不是application/x-www-form-urlencoded，multipart/form-data或text/plain之一，那么其也是Preflighted Request。 preflighted request在发送真正的请求前，会先发送一个方法为OPTIONS的预请求(preflight request)，用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 由于在真正访问资源前需要发送一个请求进行探测，因此该请求被称为是Preflight Request。 什么情况下请求会变成Preflighted Request呢？ 请求方法不是GET/HEAD/POST POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain 请求设置了自定义的header字段 解决方法： 请求： function sendData() { var request = new XMLHttpRequest(), request.open('POST', 'http://public-data.com/someData', true); request.setRequestHeader('X-CUSTOM-HEADER', 'custom_header_value'); // 自定义请求头 request.onreadystatechange = handler; request.send(payload); } 浏览器首先发出的第一个请求将如下所示： OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: OPTION Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com 首先发送的是OPTION请求（而非POST请求）。 该请求还通过Access-Control-Request-Method以及Access-Control-Request-Headers标示了请求类型以及请求中所包含的自定义HTTP Header。 这个请求相当于浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单中，以及哪些http动词和头信息字段可以使用。只有得到肯定答复，浏览器才做出正式的XMLHttpRequest请求，否则就报错 服务器收到\"预检\"请求（OPTIONS请求）以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 浏览器分析该响应并了解到其被允许向服务端发送数据以后，其才会向服务端发送真正的POST请求： POST /someData/ HTTP/1.1 Host: public-data.com 而服务端则会接收并处理该请求： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://ambergarden.com Content-Type: application/xml 3.2.3、 Requests with Credential 一个跨域请求包含了当前页面的用户凭证，那么其就属于Requests with Credential。 function retrieveData() { var request = new XMLHttpRequest() request.open('GET', 'http://public-data.com/someData', true) request.withCredentials = true // 设置Requests with Credential request.onreadystatechange = handler request.send() } 而在服务端的响应中，其将拥有一个额外的Access-Control-Allow-Credentials响应头： Access-Control-Allow-Origin: http://ambergarden.com Access-Control-Allow-Credentials： true // 开启这个配置项时，Access-Control-Allow-Origin不能取* 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 4、canvas操作图片的跨域问题 图片服务器需要配置 Access-Control-Allow-Origin 虽然JS代码这里设置的是空字符串，实际上起作用的属性值是anonymous 图片设置 var img = new Image() img.crossOrigin = ''; // 设置image对象的crossorigin字段 img.onload = function () { context.drawImage(this, 0, 0) context.getImageData(0, 0, this.width, this.height) } crossOrigin可以有下面两个值： 关键字 释义 anonymous 元素的跨域资源请求不需要设置凭证标志 use-credentials 元素的跨域资源请求需要设置凭证标志，意味着该请求需要提供凭证 其中，只要crossOrigin的属性值不是use-credentials，全部都会解析为anonymous，包括空字符串，包括类似'abc'这样的字符。 crossOrigin属性为什么可以解决资源跨域问题？ crossOrigin=anonymous相对于告诉对方服务器，你不需要带任何非匿名信息过来。例如cookie，因此，当前浏览器肯定是安全的。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-24 21:22:53 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 http","keywords":"","body":"第四章 http 1、http消息结构组成 2、列举常用的http方法并介绍get与post请求的区别 3、常见的http状态码 4、http/1.1相比http/1.0有什么优点 5、http/2.0有哪些新特性 6、简述https工作原理 7、TCP协议 8、什么是CDN 1、http消息结构组成 HTTP消息结构组成 客户端请求消息：请求行、请求头部、请求正文 服务器响应消息：状态行、响应头、响应正文 1.1、 请求报文 请求行 请求方法 URL 协议/版本 GET www.baidu.com HTTP/1.1 请求头部 头部字段名 + 冒号（:） + 值 + 回车符 + 换行符 参考文章：《HTTP常用头部信息》 场景： RequestHeader 例子 描述 Host www.uuid.online 请求的目标域名和端口号 Origin http://localhost:8081/ 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息） Referer https:/localhost:8081/link?query=xxxxx 请求资源的完整URI User-Agent Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 浏览器信息 Cookie BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0 当前域名下的Cookie Accept text/html,image/png 代表客户端希望接受的数据类型是html或者是png图片类型 Accept-Encoding gzip, deflate 代表客户端能支持什么样的压缩格式 Accept-Language zh-CN,zh;q=0.9 代表客户端可以支持语言 zh-CN 或者 zh (值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里 zh-CN 是1， zh 是0.9) Connection keep-alive 告诉服务器，客户端需要的 tcp 连接是一个长连接 请求正文 一般使用在 POST 方法中， GET 方法不存在请求正文。 POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。 1.2、 响应报文 状态行 协议版本 状态码 状态码描述 HTTP/1.1 200 OK 常见的状态码： 状态码 说明 200 响应成功 302 跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别） 304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400 客户端请求有语法错误，不能被服务器识别 403 服务器接收到请求，但是拒绝提供服务（认证失败） 404 请求资源不存在 500 服务器内部错误 响应头部 参考文章：《HTTP常用头部信息》 举例： Response Header 描述 Date: Mon, 30 Jul 2018 02:50:55 GMT 服务端发送资源时的服务器时间 Expires: Wed, 31 Dec 1969 23:59:59 GMT 较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页 Cache-Control: no-cache 现在最多使用的控制缓存的方式，会和服务器进行缓存验 etag: \"fb8ba2f80b1d324bb997cbe188f28187-ssl-df\" 一般是Nginx静态服务器发来的静态文件签名，浏览在没有 “Disabled cache” 情况下，接收到 etag 后，同一个 url 第二次请求就会自动带上 “If-None-Match” Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT 服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容 Content-Type: text/html; charset=utf-8 如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码 Content-Encoding: gzip 告诉客户端，应该采用gzip对资源进行解码 Connection: keep-alive 告诉客户端服务器的tcp连接也是一个长连接 响应正文 2、列举常用的http方法并介绍get与post请求的区别 2.1、 http请求方法 根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP/1.0 定义了三种请求方法： GET, POST, PUT, DELETE和HEAD方法。 HTTP/1.1 新增了五种请求方法：OPTIONS, TRACE和CONNECT方法。 get：这种方法是将信息存储在url中，既不安全，还无法传递太大的数据。 post：向指定的路径提交数据进行处理请求，一般用于表单的提交数据。 注意：数据包含在请求体中。post请求可能会导致新的资源或以有的资源被修改。 注意:这一方法可以不必传输整个响应内用的情况下，就可以获取包含在响应消息头中的原信息。 put：从客户端向服务器传送的数据取代指定的文档内容。 delete：请求服务器删除指定的页面 head：与get请求相似的响应，但是请求体不会被返回。 options：返回服务器针对特定资源所支持的http请求方法。 options用于什么场景 preflighted request在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 由于在真正访问资源前需要发送一个请求进行探测，因此该请求被称为是Preflight Request。 trace：返回显示服务收到的请求，主要用于测试或诊断 connect：http/1.1协议中预留给能够将链接改为管道方式的代理服务 2.2、 get与post请求的区别 区别内容 GET POST 点击返回/刷新按钮 没有影响 数据会重新发送（浏览器将会提示“数据被重新提交”） 缓存 可以 不可以 历史记录 有 没有 长度限制 有 没有 安全性 查询字符串会显示在地址栏的 URL 上，不安全，请不要使用 GET 请求提交敏感数据 因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，请使用数据加密。 可见性 查询字符串在地址栏的 URL 中可见 查询字符串在地址栏的 URL 中不可见 数据类型限制 只允许 ASCLll 字符类型 没有限制，允许二进制数据 添加书签 可以 不可以 get会产生一个tcp数据包，post两个。 具体就是： get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据） post请求时，浏览器先发送headers，服务器响应100continue，浏览器再发送data，服务器响应200（返回数据）。 这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现） 3、常见的http状态码 状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 100 客户必须继续发出请求 101 客户要求服务器根据请求转换HTTP协议版本 2xx：成功–表示请求已被成功接收、处理 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 3xx：重定向–要完成请求必须进行更进一步的操作。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304（使用缓存）自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 4xx：客户端错误–请求有语法错误或请求无法实现。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 资源未找到 5xx：服务器端错误–服务器未能实现合法的请求。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 4、http/1.1相比http/1.0有什么优点 增加持久性连接 也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个TCP连接，减少了建立和关闭连接的消耗和延迟。 响应头部中设置Connection: keep-alive 增加管道机制 增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。 分块传输 在 HTTP/1.1 版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 增加 host 字段 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 错误提示 HTTP/1.1 引入了一个 Warning 头域，增加对错误或警告信息的描述，此外，在 HTTP/1.1 中新增了24个状态响应码(100，101，203，205，206，301，305… )。 带宽优化 HTTP/1.1 加入了一个新的状态码 100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。 100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。 注意，HTTP/1.0 的客户端不支持 100 响应码。但可以让客户端在请求消息中加入 Expect头域，并将它的值设置为 100-continue。 5、http/2.0有哪些新特性 二进制分帧 在应用层（HTTP/2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。 可见，虽然 HTTP/2.0 的协议和 HTTP1.x 协议之间的规范完全不同了，但是实际上 HTTP/2.0并 没有改变 HTTP1.x 的语义。 简单来说，HTTP/2.0 只是把原来 HTTP1.x 的 header 和 body 部分用 frame 重新封装了一层而已。 多路复用（连接共享） 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，这个强大的功能则是基于“二进制分帧”的特性。 从图中可见，所有的 HTTP/2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。 首部压缩 HTTP1.1 不支持 header 数据的压缩，HTTP/2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 header ，减少发送包的数量从而降低延迟。 服务器推送 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，而无需客户端明确的请求。 6、简述https工作原理 6.1、https协议概念 HTTP协议：一种使用明文数据传输的网络协议。 HTTPS协议：可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密和身份认证。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。 HTTPS就是HTTP 加上数据加密处理和身份认证以及完整性校验。 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，利用对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 6.2、https工作原理 证书验证阶段 （1）浏览器发起 HTTPS 请求 浏览器里面输入一个HTTPS网址，然后连接到服务端的443端口上。注意这个过程中客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单。 （2）服务端返回 HTTPS 证书 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。 这套证书其实就是一对公钥和私钥。可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。 返回的证书还包含了很多信息，如证书的颁发机构、过期时间等等。 服务器从报文文本生成一个128位的散列值（hash值），发送方使用自己的私钥对这个散列值进行加密形成数字签名 （3）客户端验证证书是否合法，如果不合法则提示告警；验证合法则在本地生成随机数，通过公钥加密随机数，并把加密后的随机数传输到服务端 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如证书的颁发机构CA、证书的有效期、公钥、证书所有者、签名等等，如果发现异常则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，浏览器使用相同的hash算法计算出服务器发来的原始报文（证书）的hash值，再用服务器发来的公钥对证书里面的数字签名进行解密，将计算的hash值与签名做对比，对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器就可以读取证书中的公钥，用于后续加密了。 那么就生成一个随机值（会话密钥），然后用公钥对该随机值进行加密，然后返回给服务端。 注意一下上面提到的\"发现异常\"。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是\"发现异常\"，说明该证书是伪造的。 （4）服务端通过私钥对随机数（会话密钥）进行解密 服务端用私钥解密后，得到了客户端传过来的随机值（会话密钥），至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商，然后把内容通过该值进行对称加密。 数据传输阶段 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。 6.3、HTTP 和 HTTPS 的区别 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 7、TCP协议 7.1、tcp协议概念 Tcp位于传输层， 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。 即TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。所以，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。 7.2、三次握手和四次挥手 三次握手 第一次握手：建立连接时，客户端A发送SYN包（SYN，seq=x）到服务器B，并进入SYN_SEND状态，等待服务器B确认 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=x+1），同时自己也发送一个SYN包（SYN，seq=y），即SYN+ACK包，此时服务器B进入SYN_RECV状态 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，完成三次握手 四次挥手 客户端A发送一个FIN（FIN=1，seq=n），用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（ACK=n+1） 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（FIN=1，seq=m） 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（ACK=m+1） 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接**。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。先进行关闭的一方将执行主动关闭，而另一方被动关闭。 7.3、TCP和UDP区别 TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。 TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。 TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。 TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。 7.4、扩展 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有的话可能会导致最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。Server发出FIN之后，如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 MSL的定义，MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。 【问题3】为什么不能用两次握手进行连接？ 三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，可能发生死锁。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 8、什么是CDN CDN就是内容分发网络，加速网络传输，就是通过将资源部署到世界各地，用户访问时按照就近原则从最近的服务器获取资源，从而提高获取资源的速度。 CDN加速意思就是在用户和服务器之间加一个缓存机制，通过这个缓存机制可以动态的获取IP地址根据地理位置，让用户到最近的服务器访问。 CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 安全","keywords":"","body":"第五章 安全 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 性能","keywords":"","body":"第六章 性能 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter7/":{"url":"Chapter7/","title":"第七章 React","keywords":"","body":"第七章 React Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter8/":{"url":"Chapter8/","title":"第八章 算法","keywords":"","body":"第八章 算法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter9/":{"url":"Chapter9/","title":"第九章 数据结构","keywords":"","body":"第九章 数据结构 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter10/":{"url":"Chapter10/","title":"第十章 设计模式","keywords":"","body":"第十章 设计模式 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "},"Chapter11/":{"url":"Chapter11/","title":"第十一章 前端构建","keywords":"","body":"第十一章 前端构建 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-18 20:07:23 "}}