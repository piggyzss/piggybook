{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 最近参加面试的过程中，将自己前端知识树重新梳立了一遍，现汇总整理如下，不仅作为自己准备面试的map，也是对以往学习内容的集中复盘和回顾。 内容主要分为Javascript、html、浏览器、http、安全、性能、React、算法、数据结构、设计模式、前端构建，后续会视情况陆续补充node、vue等内容。 如果你有好的意见或建议，请邮件联系我1158591034@qq.com。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter1/":{"url":"Chapter1/","title":"第一章 Javascript","keywords":"","body":"第一章 Javascript 第1节：基础 第2节：原理性实现 第3节：常见解决方法 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter1/基础.html":{"url":"Chapter1/基础.html","title":"第1节：基础","keywords":"","body":"第1节： 基础 1、数据类型 2、执行上下文 3、this 4、作用域和作用域链 5、闭包 6、原型 7、继承 1、数据类型 1.1、数据类型 基本类型：Number，String，Boolean，Symbol，Undefined，Null 引用类型：Object，Array，Function 1.2、数据类型判断 typeof typeof 返回的是字符串，有六种可能： \"number\"、\"string\"、\"boolean\"、\"object\"、\"function\"、\"undefined\" typeof null --> \"object\" typeof [1,2,3] --> \"object\" typeof NaN --> \"number\" Object.prototype.toString.call 利用object的原型方法toString能返回相应的类型： Object.prototype.toString.call(123) // \"[object Number]\" Object.prototype.toString.call('') // \"[object String]\" Object.prototype.toString.call(true) // \"[object Boolean] Object.prototype.toString.call(Symbol()) // \"[object Symbol]\" Object.prototype.toString.call(null) // \"[object Null]\" Object.prototype.toString.call(undefined) // \"[object Undefined]\" Object.prototype.toString.call({a:1}) // \"[object Object]\" Object.prototype.toString.call([1,2]) // \"[object Array]\" Object.prototype.toString.call(function(){}) // \"[object Function]\" instanceof 判断构造函数（右边）的 prototype 属性是否出现在某个实例对象（左边）的原型链上。 [1,2] instanceof Array // true (function(){}) instanceof Function // true ({a:1}) instanceof Object // true constructor (2).constructor === Number // true (true).constructor === Boolean // true ('str').constructor === String // true ([]).constructor === Array // true (function() {}).constructor === Function // true ({}).constructor === Object // true 1.3、隐式类型转换 1.对象和字符串进行比较时，对象转换为字符串，然后两者进行比较 [1,2,3] == '1,2,3' // true，[1,2,3] 转化为 '1,2,3' 2.对象和数字比较时，对象转化为字符串,然后转换为数字，再和数字进行比较 [1] == 1 // true，[1]转换为'1'再转换为1 3.对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字 [] == false // true，[]转换为字符串'',然后再转换为数字0，false转换为数字0 4.字符串和数字比较时，字符串转换为数字 '1' == 1 5.布尔值和数字进行比较时，布尔转换为数字 true == 1 6.字符串和布尔值进行比较时，二者全部转换成数值再比较 '1' == true 总结： 对象 | 字符串 布尔 | | 数值 2、执行上下文 执行上下文包括全局执行上下文、函数执行上下文、eval 执行上下文 执行上下文(执行上下文环境)实际上是做以下准备工作： 变量、函数表达式——变量声明，默认赋值为undefined this——赋值 函数声明——赋值 程序执行进入一个执行环境时，它的执行上下文就会被创建，并被推入执行栈中(入栈)；程序执行完成时，它的执行上下文就会被销毁，并从栈顶被推出(出栈)，控制权交由下一个执行上下文。 因为JS执行中最先进入全局环境，所以处于\"栈底的永远是全局环境的执行上下文\"。而处于\"栈顶的是当前正在执行函数的执行上下文\"，当函数调用完成后，它就会从栈顶被推出。 因此在一个JavaScript程序中，必定会产生多个执行上下文，JavaScript引擎会以栈的方式来处理它们，这个栈称为函数调用栈(call stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。 3、this 3.1、this是什么 this的作用就是在函数体内部获取当前的运行环境。 3.2、this 的四种绑定规则 this绑定规则有：默认绑定、隐式绑定、显示绑定、new 绑定 默认绑定 在没有其他绑定规则时，或者说当只有一个独立函数被调用时，this指向的是window对象。 在严格模式下（\"use strict\";），全局对象将无法使用默认绑定，即执行会报undefined的错误。 隐式绑定 函数是作为某个对象的方法调用的，即调用位置上存在上下文对象。 this进行了隐式绑定，即this绑定到了对象obj上 显式绑定 显式绑定就是通过apply，call，bind，直接将函数中的this绑定到想要的对象上 显式绑定主要是通过改变对象的proto关联对象 new 绑定 使用new操作符，可以将函数的this指向新创建的对象。 3.3、优先级 判断this绑定的顺序： （1）判断是否是new调用，是的话就是new绑定，函数中的this会指向新构造的对象。 （2）判断是否是显示绑定，即是否是通过函数原型中的apply方法或者call方法调用 （还要注意bind返回的函数，this指向也会被修改）。 （3）判断是否是隐式绑定，及通过某个对象调用。是的话，this会指向所属对象。 （4）如果都没有的话，就是默认绑定，this指向全局对象window；严格模式下指向undefined。 总结：new绑定 > 显式绑定 >隐式绑定 > 默认绑定 3.4、箭头函数 通过“=>”而不是function创建的函数，叫做箭头函数。它的this绑定取决于外层（函数或全局）作用域。 简单来说，就是捕获函数定义位置作用域的 this，作为自己函数内部的 this。 箭头函数在定义时就绑定了this，而非取决于调用位置，同样用call、apply、bind都无法更改this。 4、作用域和作用域链 作用域 作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期。 --全局作用域：没有在函数内声明或未通过var声明的变量。 --局部作用域：JS没有块级作用域，只有函数级作用域，变量在声明它们的函数体内及其子函数內都是可见的。 tips：ES6之后，可以通过let/const声明块级作用域的变量。 作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链来保证对执行环境有权访问的变量和函数的有序访问。 当一个变量在当前作用域下找不到该变量定义，那么JS引擎会沿着作用链往上查找。 具体来说：就是把函数自身的本地变量放在最前面，把父级函数的变量放在其次，把再高一级函数中的变量放在更后面，以此类推直到全局变量为止。 函数作用域可以通过作用域链访问到外部甚至全局的变量，而外部想要访问内部的变量或函数，则需要通过闭包。 5、闭包 5.1、闭包概念 定义：函数访问了上层作用域的变量，并且在当前作用域之外执行，就会形成闭包 判定准则：执行时是否在内部定义的函数中访问了上层作用域的变量。 函数与创建该函数的词法环境（lexical environment）共同构成闭包（closure）。这个环境指的是函数创建时，它可以访问的所有变量。 function init() { var name = \"Hello\"; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 } return displayName(); // 闭包被返回 } var fun = init(); fun(); 通过这个返回的闭包，我们就可以访问这个函数所相关联的词法环境或者说数据。本来应该被销毁的 name 变量保留了下来。 5.2、【经典面试题目】 for (var i=1; i 因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法： for (var i=1; i （1）闭包 for (var i = 1; i （2）使用 setTimeout 的第三个参数 for ( var i=1; i （3）使用 let 定义 i for (let i=1; i 扩展 setTimeout有三个参数：参数一为一个函数，我们通过该函数定义将要执行的操作；参数二为一个时间毫秒数，表示延迟执行的时间；参数三是给setTimeout第一个函数的参数。 每一个setTimeout在执行时，会返回一个唯一ID，唯一ID保存起来用以传入clearTimeout来清除定时器。 5.3、闭包的应用 数据隐藏和封装 var counter = (function() { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value: function() { return privateCounter; } }; })(); 可以通过一个匿名的立即执行的函数来创建一个共享的环境空间，环境中包含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。 它俩都无法在匿名函数外部直接访问。只有通过匿名包装器返回的属性或方法数才能被外界访问，这样就达到了数据的隐藏封装，不污染全局环境的目的。 使用闭包设计单例模式 class CreateUser { constructor(name) { this.name = name; this.getName(); } getName() { return this.name; } } // 代理实现单例模式 var ProxyMode = (function() { var instance = null; return function(name) { if(!instance) { instance = new CreateUser(name); } return instance; } })(); // 测试单体模式的实例 var a = ProxyMode(\"aaa\"); var b = ProxyMode(\"bbb\"); // 因为单体模式是只实例化一次，所以下面的实例是相等的 console.log(a === b); //true 5.4、闭包缺点 闭包会对脚本性能具有负面影响，包括处理速度和内存消耗。 6、原型 prototype 每个函数都有 prototype 属性(除了 Function.prototype.bind())，这个属性是一个指针，指向一个对象，这个对象包含可以由这个函数new出的所有实例共享的属性和方法。这是一个显式原型属性，只有函数才拥有该属性。 proto 每个对象都有 proto属性，指向了创建该对象的构造函数的原型(也就是构造函数的prototype)。这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。 因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 proto 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。 当我们使用 new 操作符时，实际上就是使生成的实例对象的proto_属性指向对应构造函数的prototype。 7、继承 7.1、ES5继承方式 在ES6之前，继承的实现方式主要有以下几种：原型链继承、构造继承、组合继承、寄生组合继承。 原型链继承 将父类的实例作为子类的原型 function Parent () { this.name = 'kevin' } Parent.prototype.getName = function () { console.log(this.name) } function Child () {} Child.prototype = new Parent() var child = new Child() 缺点： 1.引用类型的属性被所有实例共享 2.在创建子类的实例时，不能向父类传参 构造继承 使用父类的构造函数来增强子类实例 function Parent () { this.name = 'kevin' } Parent.prototype.getName = function () { console.log(this.name) } function Child () {} Child.prototype = new Parent() var child = new Child() 组合继承 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 缺点：会调用两次父构造函数，一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候 寄生组合继承 function parent(name){ } parent.prototype.getName = function(){ } function child(name){ parent.call(this,name) } //重要 function F(){} F.prototype = parent.prototype child.prototype = new F() 7.2、class class是ES6中引入的继承机制，他实际是Javascript关于原型继承机制的语法糖，本质上是对原型继承的封装。 extends关键字 把子类实例child的原型对象(Child.prototype) 的原型(proto)指向了父类parent的原型对象(Parent.prototype)。 把子类构造函数(Child)的原型(proto)指向了父类构造函数(Parent)。 function _extends(Child, Parent){ Child.prototype.__proto__= Parent.prototype Child.prototype.constructor = Child // Object.setPrototypeOf(), 为现有对象设置原型 // 等价于Child.__proto__ = Parent Object.setPrototypeOf(Child, Parent) } super关键字 子类构造函数继承了父类构造函数的属性，通过调用super实现(ES5则用call或者apply调用传参，个人理解实际上就是完成了构造继承的这部分)。 子类继承父类时，子类没有定义constrcutor，则会默认添加一个constrcutor，并且在constrcutor中调用super，相当于调用父类的构造函数。 子类必须在constructor方法中调用super方法，否则new实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象。如果不调用super函数，子类就得不到this对象。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter1/原理性实现.html":{"url":"Chapter1/原理性实现.html","title":"第2节：原理性实现","keywords":"","body":"第2节： 原理性实现 1、debounce 2、throttle 3、bind、call、apply 4、实现instanceof 5、实现柯里化函数 6、实现compose和pipe 7、实现new 1、debounce 防抖的原理是：在事件被触发后不马上执行回调，n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 function debounce(func: Function, wait = 500) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer: any = null return function(...args: any[]) { timer && clearTimeout(timer) timer = setTimeout(() => { func(...args) }, wait) } } 2、throttle 节流的原理是：让一个函数不要执行得太频繁，减少一些过快的函数调用来节流。也就是在一段固定的时间内只触发一次回调函数 时间戳版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } // 第一次先打一个初始时间戳设置为0 var previous = 0 return function () { // 通过date.now取到当前时间，二者相减如果大于时间间隔，则调用传入的func，并且把时间戳previous设置为now var now = Date.now() if (now - previous > wait) { func.apply(this, [...arguments]) previous = now } } } 定时器版 function throttle(func, wait) { if(typeof func !== 'function') { throw new TypeError('need a function') } let timer = null return function() { // 如果判断出定时器timer为空，则会起定时器赋值给timer，定时器的回调处理函数中调用传入的func，并且清空定时器 if (!timer) { timer = setTimeout(function(){ timer = null func.apply(this, [...arguments]) }, wait) } } } 3、bind、call、apply call Function.prototype.Call = function (context) { var context = context || window // 给 context 添加一个属性 context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.Apply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind Function.prototype.Bind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { var context = context || window context.fn = this var result if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } } 4、实现instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 5、实现柯里化函数 function curry(fn) { var _this = this return function inner(...args) { // 如果参数个数小于最初的fn.length，则递归调用，继续收集参数 if (**args.length inner.call(_this, ...args, ...innerArgs)** } // 参数收集完毕，则执行fn return fn.apply(this, args) } } 扩展题目 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6 add(1, 2, 3)(4) = 10 add(1)(2)(3)(4)(5) = 15 function add() { var _args = [...arguments] return function() { if (arguments.length === 0) { return _args.reduce(function (a, b) { return a + b }) } [].push.apply(_args, [...arguments]) return arguments.callee } } add(1, 2)(1)(2)(5)() 6、实现compose和pipe 实现函数compose，compose接受多个函数作为参数，并返回一个新的函数，新的函数会从右向左依次执行原函数， 并且上一次结果的返回值将会作为下一个函数的参数。 function compose(...fns) { return (...args) => fns.reduceRight((acc, cur) => cur(acc), ...args); } compose 的数据流是从右至左的，因为最右侧的函数首先执行，将数据 传递给下一个函数，以此类推 ...... 最左侧的函数最后执行；而管道的数据流是 从左至右的。 实现一个管道函数： const pipe = (...fns) => (...args) => fns.reduce((acc, cur) => cb(cur) , args) 7、实现new 创建一个空的新对象 新对象的proto属性指向构造函数的原型对象 绑定this，执行构造函数 返回新对象 function create () { let obj = new Object() let constructor = [].shift.apply(arguments) obj.__proto__ = constructor.prototype let result = constructor.apply(obj, arguments) return typeof result === \"object\" ? result : obj } 8、实现Promise 规范 Promise规范有很多，如Promise/A，Promise/B，Promise/D以及 Promise/A的升级版 Promise/A+。ES6中采用了 Promise/A+规范。 英文版规范: Promises/A+规范 中文版规范: Promises/A+规范(中文) Promise标准解读 (1) 一个promise的当前状态只能是pending、fulfilled和rejected三种之一。状态改变只能是pending到fulfilled或者pending到rejected。状态改变不可逆。 (2) promise的then方法接收两个可选参数，表示该promise状态改变时的回调(promise.then(onFulfilled, onRejected))。then方法返回一个promise。then方法可以被同一个 promise调用多次。 Promise实现 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter1/常见解决方法.html":{"url":"Chapter1/常见解决方法.html","title":"第3节：常见解决方法","keywords":"","body":"第3节：常见解决方法 1、深拷贝 2、实现一个ajax 3、数组去重 4、周期性执行一个函数n次 5、基于promise实现重试功能 6、实现一个休眠函数 1、深拷贝 function deepCopy(src){ if (!src | !(src instanceof Object) | (typeof src === \"function\")) { return src || undefined } var constructor = src.constructor var dst = new constructor() for (var key in src) { if (src.hasOwnProperty(key)) { dst[key] = deepCopy(src[key]) } } return dst } 2、实现一个ajax function getData(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onreadystatechange = handler; xhr.responseType = \"json\"; xhr.setRequestHeader(\"Accept\", \"application/json\"); xhr.send(); }); return promise; }; 3、数组去重 set去重 [...(new set([]))] 基本数组去重 Array.prototype.unique = function() { var result = [] this.forEach((val) => { if(result.indexOf(val) 利用hash表去重，空间换时间 ** Array.prototype.unique = function() { var hash = {} var result = [] this.forEach((val) => { if(!hash[val]) { obj[val] = true result.push(val) } }) return result } 4、周期性执行一个函数n次 function circlExe(fn, wait=0, num=0){ var count = 0 function inner() { if(count >= num) { return } count++ setTimeout(() => { inner.call(this, ...arguments) fn.call(this, ...arguments) }, wait) } return inner } 5、基于promise实现重试功能 function getData(delay){ return new Promise(function(resolve, reject){ setTimeout(function(){ var num = Math.ceil(Math.random()*20); //生成1-10的随机数 console.log('随机数生成的值：',num) if(num 打印结果： 随机数生成的值： 17 还有 5 次尝试 随机数生成的值： 15 还有 4 次尝试 随机数生成的值： 16 还有 3 次尝试 随机数生成的值： 20 还有 2 次尝试 随机数生成的值： 16 还有 1 次尝试 随机数生成的值： 15 还有 0 次尝试 6、实现一个休眠函数 封装一个休眠函数，入参是定时器的等待时间，.then执行回调函数 function sleep (time) { return new Promise((resolve) => setTimeout(resolve, time)); } Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter2/":{"url":"Chapter2/","title":"第二章 HTML & CSS","keywords":"","body":"第二章 HTML & CSS 第1节：HTML 第2节：CSS Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter2/HTML.html":{"url":"Chapter2/HTML.html","title":"第1节：HTML","keywords":"","body":"第1节：HTML 1、html语义化的理解 2、script标签 3、href和src的区别 4、把CSS放头部，script放尾部的原因 5、meta标签有什么作用 1、html语义化的理解 用合理、正确的标签展示内容 语义化可以使页面内容结构更清晰，在没有css样式的情况下，也会以一种文档的格式显示，并且是容易阅读的 搜索引擎的爬虫也依赖于HTML标记确定上下文和各个关键字的权重，利于seo 更易理解维护，比如头部、、页面导航、侧边栏、分组内容 2、script标签 defer：只适用于外部脚本文件。脚本会立即下载，但是会延迟到整个页面全部加载完毕之后再运行。defer多个脚本是按照顺序执行的，如果有依赖关系，需要特别注意脚本顺序。 async：同样只适用于外部脚本。浏览器立即下载脚本，但是下载完毕之后立即执行，运行的同时并不阻止浏览器去解析下面的内容。使用async主要是脚本下载时并不影响页面的渲染。多个async脚本之间不能保证运行顺序 如果不使用 async 且 defer=“defer”：脚本将在页面完成解析时执行，因为defer表示脚本下载完并不执行而是等页面全部加载完之后再执行。 如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本。 charset：规定在外部脚本文件中使用的字符编码 type src：规定外部脚本文件的 URL 3、href和src的区别 href（hypertext reference）：表示超文本引用，用来建立当前元素和文档间的链接。 常用的有link，a 当CSS使用href引用，浏览器会识别该文档问CSS，并行下载，不会停止对当前文档的加载。 src（source）：src指向的内容会嵌入到文档中当前标签的位置 常用的有img, script, iframe 浏览器解析到该元素时会停止对文档的渲染，直到该资源加载完成。这也是将script放底部而不是头部的原因。 4、把CSS放头部，script放尾部的原因 为什么css放在头部？ 外链css无论放在html的任何位置都不影响html的解析，但是影响html的渲染。 如果将css放在头部，css的下载解析是可以和html的解析同步进行的 放到尾部，要花费额外时间来解析CSS，并且浏览器会先渲染出一个没有样式的页面，等CSS加载完后会再渲染成一个有样式的页面，页面会出现明显的闪跳的现象。 这样可以防止闪跳，白屏或者布局混乱。 为什么script放在尾部？ 因为当浏览器解析到script的时候，中断html的解析过程，直到该资源加载完成。 如果外部脚本加载时间很长（比如一直无法完成下载），就会造成网页长时间失去响应，浏览器就会呈现“假死”状态 其实现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssdom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。 5、meta标签有什么作用 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-28 17:09:50 "},"Chapter2/CSS.html":{"url":"Chapter2/CSS.html","title":"第2节：CSS","keywords":"","body":"第2节：CSS 1、盒模型 2、BFC 3、清除浮动 4、定位机制 5、水平居中/垂直居中 6、flex布局 7、实现一个两边宽度固定中间自适应的三列布局 1、盒模型 盒模型:content、padding、border、margin 标准模型 box-sizing:content-box IE模型 box-sizing:border-box div{ height: 100px; width: 100px; border: 10px solid red; padding: 10px; box-sizing:content-box; 实际大小为140px*140px; box-sizing:border-box; 实际大小为100px*100px; } 2、BFC BFC(Block Formatting Context , 块级格式化上下文) BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。 官方定义： 浮动元素、绝对定位元素、不是块级盒的包含块（比如inline-block、tabel-cell、tabel-captain）、和overflow值不为visible的块级盒子为他们的内容建立了一个新的块级排版上下文 在一个BFC中，盒子是从包含块顶部开始放置的，他们会在垂直方向一个接一个的排列 盒子垂直方向的距离由margin决定，属于同一个bfc的两个相邻box的margin会发生重叠 bfc是一个页面上的独立的容器，外面的元素不会影响bfc里的元素，反过来，里面的也不会影响外面的 计算bfc高度的时候，浮动元素也会参与计算 怎么取创建BFC float属性不为none（脱离文档流） position为absolute或fixed display为inline-block、table-cell、table-caption、flex、inine-flex overflow不为visible 3、清除浮动 3.1、浮动产生的问题 不清除浮动，浮动层后面跟随的非浮动内容就有可能被浮动层所覆盖，造成版面混乱 在文档流中，父元素的高度未设置时，默认是被子元素撑开的，也就是说子元素多高，父元素就多高。但当子元素被设置浮动之后，它会完全脱离文档流，此时会导致子元素无法撑起父元素的高度，从而导致父元素的高度塌陷。 3.2、解决浮动的方法 增加一个空标签 .div1{border:1px solid red} .left{float:left; width:20%; height:200px;} .right{float:right; width:30%; height:80px;} /*清除浮动代码*/ .clearfloat{clear:both} Left Right 优点：浏览器支持好 缺点：增加了无意义的空标签 利用br标签 优点：比空标签方式语义稍强 缺点：有悖结构与表现分离的原理 父元素overflow:auto或overflow:hidden 优点：不存在结构和语义化问题 缺点：内容超出父级元素时，auto会产生滚动条，hidden会隐藏部分内容 伪元素 .parent{border:1px solid red} .parent:after{ content:\"\"; display:block; clear:both; } 优点：结构和语义化完全正确 4、定位机制 position有四个属性值：static、relative、absolute、fixed static position的默认值，按照正常的文档流进行排列。 当元素未定义position或定义position值为static时，该元素内定义的top, bottom, left, right 和 z-index无效。 relative 相对定位，按照正常的文档流进行排列，相对于元素在文档流中的位置进行偏移，会依据top，right，bottom，left等属性在正常文档流中偏移位置。 absolute 绝对定位，脱离正常文档流，不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。 绝对定位之后，标签就不再区分行内元素和块级元素了，可以设置宽高（无需display）。 fixed 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。 5、水平居中/垂直居中 5.1、水平居中 行内元素：设置text-align: center 块级元素：margin: 0 auto 5.2、垂直居中 行内元素：设置line-height：height 块级元素：利用tabel属性 #parent{ display: table; } #child{ display: table-cell; } /**center code**/ vertical-align: middle; /**center code**/ 在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式 5.3、块级元素水平垂直均居中 利用flex display: flex; flex-direction: column; justify-content: center; align-items: center; 利用定位 #parent{ position: relative; } #child{ width: 100px; height: 100px; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); // margin:-50px 0 0 -50px; } 或 #parent{ position:relative; } #child{ position:absolute; margin:auto; top:0; bottom:0; left:0; right:0; } 6、flex布局 6.1、flex布局 flex布局即弹性盒布局，用来为盒状模型提供最大的灵活性。 设为 flex 布局以后，子元素的float、clear和vertical-align属性将失效。 6.2、容器元素属性 flex-direction：row | row-reverse | column | column-reverse // 子元素的主轴方向 flex-wrap：nowrap | wrap | wrap-reverse // 换行方式 flex-flow： flex-direction || flex-wrap justify-content：flex-start | flex-end | center | space-between | space-around // 主轴的对齐方式 align-items：flex-start | flex-end | center | baseline | stretch // 交叉轴上如何对齐 align-content：flex-start | flex-end | center | space-between | space-around | stretch //多根轴线的对齐方式 6.3、子元素属性 order：num // 排列顺序 flex-grow：num // 放大比例，默认为0，即如果存在剩余空间，也不放大 flex-shrink：num // 缩小比例，默认为1，即如果空间不足，该项目将缩小，如果为0，其他项目都为1，则空间不足时，前者不缩小 flex-basis：length // 在分配多余空间之前，项目占据的主轴空间（main size），默认值为auto，即项目的本来大小 flex：flex-grow flex-shrink flex-basis // 0 1 auto .item { flex: 1; } 等同于 .item { flex-grow: 1; flex-shrink: 1; flex-basis: 0%; } align-self：auto | flex-start | flex-end | center | baseline | stretch // align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 【Tips】 对于flex-basis的说明 这个属性决定CSS如何给可伸缩项在容器中分配初始大小（为简化讨论，以下一律假定“大小”为宽度，高度与之类似）。以下是这个属性几种常用的值： auto（默认值）：auto的意思是首先看当前项有没有明确设置宽度，如果有则使用该宽度；如果没有，则以包含的内容决定宽度。 content：content是不管当前项是否明确设置了宽度，一律以内容决定宽度 长度或百分比值：百分比是相对于容器而言的。知道了每一项的宽度，简单相加就能得到所有项宽度的总和。而知道了所有项宽度的总和，再与容器宽度比较，就能知道容器里是不是还有剩余空间可供再次分配。 Flex Items的应用准则：content –> width –> flex-basis 也就是说： 如果没有设置flex-basis属性，那么flex-basis的大小就是项目的width属性的大小 如果没有设置width属性，那么flex-basis的大小就是项目内容(content)的大小 **如果同时设置了flex-basis属性和width属性，那么以flex-basis为准 头条题目：常见的css伪类 7、实现一个两边宽度固定中间自适应的三列布局 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:49:45 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 浏览器","keywords":"","body":"第三章 浏览器 第1节：浏览器运行机制 第2节：强缓存和协商缓存 第3节：跨域问题 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter3/浏览器运行机制.html":{"url":"Chapter3/浏览器运行机制.html","title":"第1节：浏览器运行机制","keywords":"","body":"第1节：浏览器运行机制 1、进程和线程 2、为什么JS是单线程 3、单线程怎样实现异步 4、event loop 5、处理异步的几种方法 1、进程和线程 1.1、进程和线程 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位） 一个进程可以包含多个线程。 一个进程內的内存空间是共享的，每个线程都可以使用这些共享内存，一个线程使用某些共享内存时，其他线程必须等待结束后才能使用。 一个进程中至少有一个运行的主线程，进程启动后自动创建。 线程是cpu调度的最小单位 ----单线程： 优点：顺序编程简单易懂 缺点：效率低 ----多线程： 优点：有效提升cpu利用率 缺点： 线程间切换开销 对线程进行管理要求额外的 CPU开销。线程的使用会给系统带来上下文切换的额外负担。当这种负担超过一定程度时，多线程的特点主要表现在其缺点上,比如用独立的线程来更新数组内每个元素。 线程的死锁 即较长时间的等待或资源竞争以及死锁等多线程症状。 访问临界资源（不同线程可共享的数据） 多个线程同时对共享数据（临界资源）进行操作时往往会发生不可预知的情况，当临界资源的操作是非原子性时，在不同的机器上，中断时间的不确定性，会导致数据在一个线程内的操作产生错误，从而产生莫名其妙的错误，而这种错误是程序员无法预知的。 1.2、浏览器是多进程的 浏览器是多进程的 浏览器之所以能够运行，是因为系统给它的进程分配了资源（cpu、内存） 每打开一个Tab页，就相当于创建了一个独立的浏览器进程 注意：浏览器应该也有自己的优化机制，有时候打开多个tab页后，可以在Chrome任务管理器中看到，有些进程被合并了（所以每一个Tab标签对应一个进程并不一定是绝对的）。 1.3、浏览器的内核机制 一个浏览器一般包括以下进程： Browser进程：浏览器的主进程（负责协调、主控），只有一个 第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建 GPU进程：最多一个，用于3D绘制 浏览器渲染进程（浏览器内核）：默认每个Tab页面一个进程，互不影响，控制页面渲染，脚本执行，事件处理等（有时候会优化，如多个空白tab会合并成一个进程） 每一个tab页面可以看作是一个浏览器内核进程，这个进程是多线程的，它有几大类子线程： js引擎线程：是基于事件驱动单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行JS程序。 GUI渲染线程：负责渲染浏览器界面，解析html、css，构建dom树 当界面需要重排、重绘或由于某种操作引发回流时，该线程就会执行。 但需要注意 GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。 定时器触发线程 异步http请求线程 2、为什么js是单线程 JavaScript的单线程，与它的用途有关。 引用阮一峰老师的解答： 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？ 所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。 3、单线程怎样实现异步 单线程就意味着，浏览器只分配给js一个主线程用来执行任务（函数）。 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，这类任务被称作同步任务。 但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果前一个任务耗时很长，后一个任务就不得不一直等着。这样执行效率会很低，甚至导致页面的假死。 因此，我们需要异步任务来解决这个难题。 异步任务：不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 任务队列：是一个先进先出的事件队列（也可以理解成消息的队列），IO设备完成一项任务，就在”任务队列”中添加一个事件，表示相关的异步任务可以进入”执行栈”了。主线程读取”任务队列”，就是读取里面有哪些事件。 “任务队列”中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。当主线程开始执行异步任务，就是执行对应的回调函数。 JS通过这样的机制，来实现异步处理。 4、eventloop 4.1、宏任务与微任务 所有任务分为宏任务（macrotask ）和微任务（microtask ） 两种。 MacroTask（宏任务）： script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。 MicroTask（微任务）：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver 且process.nextTick优先级大于promise.then。 4.2、eventloop javascript在执行时，整体script作为第一个宏任务放入主线程执行； 在执行过程中，如果遇到 macrotask（例如settimeout，I/O等），则将该 macrotask 放入 macrotask 队列，继续运行执行栈中的后续代码。 如果遇到microtask，那么将该microtask放入microtask队列，继续向下运行执行栈中的后续代码。 当执行栈中的代码全部执行完成后，从microtasks队列中取出所有的microtask放入执行栈执行。执行完毕后，再从macrotasks 队列取出下一个macrotask放入执行栈。 然后不断重复上述流程，这一过程就叫做事件循环（Event Loop）。 5、处理异步的几种方法 5.1、回调函数callback A callback is a function that is passed as an argument to another function and is executed after its parent function has completed.（回调是一个函数被作为一个参数传递到另一个函数里，在那个函数执行完后再执行） function foo(callback){//定义函数的时候将另一个函数（回调函数）作为参数传入定义的函数中 $ajax({ //... success: callback//异步操作执行完毕后，再执行该回调函数，确保回调在异步操作之后执行 }) } function func(result){ //... } foo(func) --优点：实现简单、容易理解 --缺点： 1.高耦合，维护困难，回调地狱 2.每个任务只能指定一个回调函数 3.如果几个异步操作之间并没有顺序之分，同样也要等待上一个操作执行结束再进行下一个操作。 5.2、事件监听 优点：比较容易理解，可以绑定多个事件，每一个事件可以指定多个回调函数，而且可以去耦合，有利于实现模块化。 缺点：每次都要手动地绑定和触发事件；并且整个程序都要变成事件驱动型，运行流程会变得不清晰。 5.3、promise promise对象是commonJS工作组提出的一种规范，目的是为了异步编程提供统一接口 Promise代表了一个异步操作，可以将异步对象和回调函数脱离开来，可以通过链式调用的方法去解决回调嵌套的问题。 promise对象有以下三个状态： Fulfilled---has-resolution，reslove(成功时)，调用onFulfilled Rejected---has-rejection，reject(失败时)，调用Rejected Pending---unresolve，Pending，既不是resolve也不是reject状态，也就是Promise刚刚被创建后的初始化状态 Promise的状态只会从Pending变为Fulfilled或者Rejected，不可逆。 promise提供以下api： 构造函数 原型方法 --Promise.prototype.then = function() {} .then为Promise实例添加状态改变时的回调函数。 .then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。 .then可以使用链式调用，原因在于：每一次执行该方法时总会返回一个Promise对象。 --Promise.prototype.catch = function() {} .catch用于指定发生错误时的回调函数。 --Promise.prototype.finally = function() {} .finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 静态方法 --Promise.resolve = function() {} .resolve方法可以使Promise对象的状态改变为成功，同时传递一个参数用于后续成功后的操作。 --Promise.reject = function() {} .reject方法可以将Promise对象的状态改变为失败，同时将错误信息传递到后续错误处理的操作。 --Promise.all = function() {} .all方法用于将多个Promise实例，包装成一个新的Promise实例。只有入参数组中所有实例的状态都变成fulfilled，状态才会变成fulfilled。 --Promise.race = function() {} .race方法同样用于将多个Promise实例，包装成一个新的Promise实例。入参数组之中有一个实例率先改变状态，状态就跟着改变。 5.4、async/await async/await就是Generator函数的语法糖，他返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，但async函数自带执行器，也就是说他并不需要调用next()就可以自动执行。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter3/强缓存和协商缓存.html":{"url":"Chapter3/强缓存和协商缓存.html","title":"第2节：强缓存和协商缓存","keywords":"","body":"第2节：强缓存和协商缓存 1、浏览器缓存 2、强缓存 3、协商缓存 4、一些状态码 1、浏览器缓存 浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。 浏览器缓存的优点有： 减少冗余的数据传输 减小服务器的负担，提升网站的性能 加快客户端加载网页的速度 浏览器的缓存分为强缓存和协商缓存。 当客户端请求某个资源的时候，获取缓存的流程如下： 浏览器进行资源请求时，会判断response headers是否命中强缓存，如果命中，直接从本地读取缓存，不会向服务器发送请求 当强缓存没有命中时，会发送请求到服务端，判断协商缓存是否命中，如果命中，服务器将请求返回，不会返回资源，告诉浏览器从本地读取缓存。如何不命中，服务器直接返回资源 2、强缓存 2.1、强缓存概念 强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来表示资源的缓存时间，他无需和服务器端进行通信。 2.2、强缓存实现 Expires Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从缓存取数据，而无需再次请求。 该字段是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon,18 Oct 2066 23:59:59 GMT。这个时间代表着这个资源的失效时间，在此时间之前即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control Cache-Control也是用于资源有效期。 该字段是http1.1时出现的header信息，他的设置更细致，如果和expires同时设置的话，其优先级高于Expires --max-age：它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒 --no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 --no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 --public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 --private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。 3、协商缓存 3.1、协商缓存概念 协商缓存就是由服务器来确定缓存资源是否可用，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问。 3.2、协商缓存实现 协商缓存主要涉及到两组头部 header字段： Etag和 If-None-Match、Last-Modified和If-Modified-Since 响应头 Last-Modified/请求头 If-Modified-Since 响应头 Last-Modified： response返回，表示为资源的最后更新时间 请求头 If-Modified-Since：通过比较两次的时间判断，资源在请求期间是否有修改，假如没有修改，则命中协商缓存，浏览器从缓存中读取资源，如果没有命中，资源有过修改，返回新的Last-Modified时间和服务器资源 整个流程： --浏览器第一次访问服务器的资源时，不会携带If-Modified-Since，因为未有本地缓存。 --服务器收到请求，开始处理。响应200，http头有标签：Last-Modified（date），即服务器本地记录的文件最后修改时间。 --浏览器收到响应，缓存到本地。 --浏览器第二次请求时，携带If-Modified-Since（date）, --服务器比较If-Modified-Since（date）,是否与服务器本地记录相同。决定返回状态200还是304. 响应头 Etag/请求头 If-None-Match 响应头 etag：就像一个指纹，资源变化都会导致ETag变化，跟最后修改时间没有关系，ETag可以保证每一个资源是唯一的 请求头 If-None-Match：header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来 整个流程： --浏览器第一次请求一个资源的时候，服务端收到请求，处理响应并且返回了ETag: \"50b1c1d4f775c61:df3\" 这样的字样给浏览器 --当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: W/\"50b1c1d4f775c61:df3\" 传输给服务端，服务端拿到该etag，对比资源是否发生变化：如果资源没更改，返回304，浏览器读取本地缓存；如果资源有更改，返回200，返回最新的资源。 ETag的优先级比Last-Modified更高 3.3、为什么需要ETag？ 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)； 某些服务器不能精确的得到文件的最后修改时间 4、一些状态码 200：强缓Expires/Cache-Control存失效时，返回新的资源文件 200(from cache): 强缓Expires/Cache-Control两者都存在，未过期，Cache-Control优先Expires时，浏览器从本地获取资源成功 304(Not Modified )：协商缓存Last-modified/Etag没有过期时，服务端返回状态码304 告诉浏览器，上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 【参考】 浏览器缓存：强缓存和协商缓存 彻底捋一捋缓存（二）——浏览器缓存机制：强缓存、协商缓存 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter3/跨域问题.html":{"url":"Chapter3/跨域问题.html","title":"第3节：跨域问题","keywords":"","body":"第3节：跨域问题 1、浏览器同源策略 2、什么是跨域问题 3、跨域的解决方案 4、canvas操作图片的跨域问题 1、浏览器同源策略 如果两个页面的协议，主机（域名）、端口都相同，则两个页面具有相同的源。 同源策略限制了以下行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 JS 对象无法获取 Ajax请求发送不出去 2、什么是跨域问题 跨域是指一个域下的文档或脚本试图请求另一个域下的资源。 广义的跨域包括： 资源跳转：a链接、重定向、表单提交 资源嵌入：、、、等标签，还有background：url()、@font-face等文档外链 脚本请求：js发起的ajax请求，dom和js对象的跨域操作 通常所说的跨域是狭义的：是由浏览器同源策略限制的一类请求场景 3、跨域的解决方案 3.1、JSONP（JSON with padding） 概念 利用 script 标签没有跨域限制的策略，通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据，从而实现跨域访问。 最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。 核心思想：网页通过添加一个元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。 实现 JSONP由两部分组成：回调函数和数据 回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数的JSON数据 客户端： let script = document.createElement('script'); script.src = 'http://localhost:1234/article-list?name=leo&age=30&callback=func'; // 向服务器发出请求，该请求的查询字符串有一个callback参数，用来指定回调函数的名字 document.body.appendChild(script); // 处理服务器返回回调函数的数据 function func(res) { console.log(res); } 服务端（node）： router.get('/article-list', (req, res) => { let data = { message: 'success!', name: req.query.name, age: req.query.age } data = JSON.stringify(data) res.end(`func(${data})`); }) 实际上拥有src属性的标签都可以跨域，比如 3.2、CORS（跨域资源共享） 它允许浏览器向跨域服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。 CORS则将导致跨域访问的请求分为三种：Simple Request，Preflighted Request以及Requests with Credential。 3.2.1、 Simple Request（简单跨域请求） 如果一个请求没有包含任何自定义请求头，而且它所使用HTTP动词是HEAD，GET或POST之一，那么它就是一个Simple Request。但是在使用POST作为请求的动词时，该请求的Content-Type需要是application/x-www-form-urlencoded，multipart/form-data或text/plain之一。 解决方法： 假设ambergarden.com想从一个公有数据平台public-data.com中返回一些数据，那么在页面逻辑中，其可以通过下面的代码向public-data.com发送数据请求： function retrieveData() { var request = new XMLHttpRequest() request.open('GET', 'http://public-data.com/someData', true) request.onreadystatechange = handler request.send() } 在运行这段代码的之后，浏览器会向服务端发送如下的请求： GET /someData/ HTTP/1.1 Host: public-data.com ...... Referer: http://ambergarden.com/somePage.html Origin: http://ambergarden.com 服务端设置通过设置Access-Control-Allow-Origin，来支持跨域。 该响应头用来记录可以访问该资源的域。在接收到服务端响应后，浏览器将会查看响应中是否包含Access-Control-Allow-Origin响应头。如果该响应头存在，那么浏览器会分析该响应头中所标示的内容。如果其包含了当前页面所在的域，那么浏览器就将知道这是一个被允许的跨域访问，从而不再根据Same-origin Policy来限制用户对该数据的访问。 然后服务端给出如下响应： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://ambergarden.com Content-Type: application/xml ...... 3.2.2、 Preflighted Request（带预检的跨域请求） 如果一个请求包含了任何自定义请求头，或者它所使用的HTTP动词是GET，HEAD或POST之外的任何一个动词，那么它就是一个Preflighted Request。如果POST请求的Content-Type并不是application/x-www-form-urlencoded，multipart/form-data或text/plain之一，那么其也是Preflighted Request。 preflighted request在发送真正的请求前，会先发送一个方法为OPTIONS的预请求(preflight request)，用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 由于在真正访问资源前需要发送一个请求进行探测，因此该请求被称为是Preflight Request。 什么情况下请求会变成Preflighted Request呢？ 请求方法不是GET/HEAD/POST POST请求的Content-Type并非application/x-www-form-urlencoded, multipart/form-data, 或text/plain 请求设置了自定义的header字段 解决方法： 请求： function sendData() { var request = new XMLHttpRequest(), request.open('POST', 'http://public-data.com/someData', true); request.setRequestHeader('X-CUSTOM-HEADER', 'custom_header_value'); // 自定义请求头 request.onreadystatechange = handler; request.send(payload); } 浏览器首先发出的第一个请求将如下所示： OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: OPTION Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com 首先发送的是OPTION请求（而非POST请求）。 该请求还通过Access-Control-Request-Method以及Access-Control-Request-Headers标示了请求类型以及请求中所包含的自定义HTTP Header。 这个请求相当于浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单中，以及哪些http动词和头信息字段可以使用。只有得到肯定答复，浏览器才做出正式的XMLHttpRequest请求，否则就报错 服务器收到\"预检\"请求（OPTIONS请求）以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 浏览器分析该响应并了解到其被允许向服务端发送数据以后，其才会向服务端发送真正的POST请求： POST /someData/ HTTP/1.1 Host: public-data.com 而服务端则会接收并处理该请求： HTTP/1.1 200 OK Access-Control-Allow-Origin: http://ambergarden.com Content-Type: application/xml 3.2.3、 Requests with Credential 一个跨域请求包含了当前页面的用户凭证，那么其就属于Requests with Credential。 function retrieveData() { var request = new XMLHttpRequest() request.open('GET', 'http://public-data.com/someData', true) request.withCredentials = true // 设置Requests with Credential request.onreadystatechange = handler request.send() } 而在服务端的响应中，其将拥有一个额外的Access-Control-Allow-Credentials响应头： Access-Control-Allow-Origin: http://ambergarden.com Access-Control-Allow-Credentials： true // 开启这个配置项时，Access-Control-Allow-Origin不能取* 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 xhr.withCredentials = false 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 3.3、Nginx代理 想一下，如果我们请求的时候还是用前端的域名，然后有个东西帮我们把这个请求转发到真正的后端域名上，不就避免跨域了吗？这时候，Nginx出场了。 Nginx配置 server{ # 监听9099端口 listen 9099; # 域名是localhost server_name localhost; #凡是localhost:9099/api这个样子的，都转发到真正的服务端地址http://localhost:9871 location ^~ /api { proxy_pass http://localhost:9871; } } 3.4、document.domain 因为浏览器是通过document.domain属性来检查两个页面是否同源，因此只要通过设置相同的document.domain，两个页面就可以共享Cookie。 这种方式只适合主域名相同，但子域名不同的跨域应用场景。 比如主域名是http://crossdomain.com:9099，子域名是http://child.crossdomain.com:9099，这种情况下给两个页面指定一下document.domain即document.domain = crossdomain.com就可以访问各自的window对象了。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 (待补充) 3.5、window.name+iframe跨域 window对象有个name属性，该属性在一个窗口的生命周期内，窗口载入的所有页面都共享一个window.name，每个页面对window.name都有读写权限，window.name是持久存在于一个窗口载入的所有页面的。 (待补充) 4、canvas操作图片的跨域问题 图片服务器需要配置 Access-Control-Allow-Origin 虽然JS代码这里设置的是空字符串，实际上起作用的属性值是anonymous 图片设置 var img = new Image() img.crossOrigin = ''; // 设置image对象的crossorigin字段 img.onload = function () { context.drawImage(this, 0, 0) context.getImageData(0, 0, this.width, this.height) } crossOrigin可以有下面两个值： 关键字 释义 anonymous 元素的跨域资源请求不需要设置凭证标志 use-credentials 元素的跨域资源请求需要设置凭证标志，意味着该请求需要提供凭证 其中，只要crossOrigin的属性值不是use-credentials，全部都会解析为anonymous，包括空字符串，包括类似'abc'这样的字符。 crossOrigin属性为什么可以解决资源跨域问题？ crossOrigin=anonymous相对于告诉对方服务器，你不需要带任何非匿名信息过来。例如cookie，因此，当前浏览器肯定是安全的。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 http","keywords":"","body":"第四章 http 1、http消息结构组成 2、列举常用的http方法并介绍get与post请求的区别 3、常见的http状态码 4、http/1.1相比http/1.0有什么优点 5、http/2.0有哪些新特性 6、简述https工作原理 7、TCP协议 8、什么是CDN 1、http消息结构组成 HTTP消息结构组成 客户端请求消息：请求行、请求头部、请求正文 服务器响应消息：状态行、响应头、响应正文 1.1、 请求报文 请求行 请求方法 URL 协议/版本 GET www.baidu.com HTTP/1.1 请求头部 头部字段名 + 冒号（:） + 值 + 回车符 + 换行符 参考文章：《HTTP常用头部信息》 场景： RequestHeader 例子 描述 Host www.uuid.online 请求的目标域名和端口号 Origin http://localhost:8081/ 请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息） Referer https:/localhost:8081/link?query=xxxxx 请求资源的完整URI User-Agent Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 浏览器信息 Cookie BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0 当前域名下的Cookie Accept text/html,image/png 代表客户端希望接受的数据类型是html或者是png图片类型 Accept-Encoding gzip, deflate 代表客户端能支持什么样的压缩格式 Accept-Language zh-CN,zh;q=0.9 代表客户端可以支持语言 zh-CN 或者 zh (值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里 zh-CN 是1， zh 是0.9) Connection keep-alive 告诉服务器，客户端需要的 tcp 连接是一个长连接 请求正文 一般使用在 POST 方法中， GET 方法不存在请求正文。 POST 方法适用于需要客户填写表单的场合。与请求数据相关的最常使用的请求头是 Content-Type 和 Content-Length。 1.2、 响应报文 状态行 协议版本 状态码 状态码描述 HTTP/1.1 200 OK 常见的状态码： 状态码 说明 200 响应成功 302 跳转，跳转地址通过响应头中的位置属性指定（JSP中Forward和Redirect之间的区别） 304 自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 400 客户端请求有语法错误，不能被服务器识别 403 服务器接收到请求，但是拒绝提供服务（认证失败） 404 请求资源不存在 500 服务器内部错误 响应头部 参考文章：《HTTP常用头部信息》 举例： Response Header 描述 Date: Mon, 30 Jul 2018 02:50:55 GMT 服务端发送资源时的服务器时间 Expires: Wed, 31 Dec 1969 23:59:59 GMT 较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页 Cache-Control: no-cache 现在最多使用的控制缓存的方式，会和服务器进行缓存验 etag: \"fb8ba2f80b1d324bb997cbe188f28187-ssl-df\" 一般是Nginx静态服务器发来的静态文件签名，浏览在没有 “Disabled cache” 情况下，接收到 etag 后，同一个 url 第二次请求就会自动带上 “If-None-Match” Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT 服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容 Content-Type: text/html; charset=utf-8 如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码 Content-Encoding: gzip 告诉客户端，应该采用gzip对资源进行解码 Connection: keep-alive 告诉客户端服务器的tcp连接也是一个长连接 响应正文 2、列举常用的http方法并介绍get与post请求的区别 2.1、 http请求方法 根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP/1.0 定义了三种请求方法： GET, POST, PUT, DELETE和HEAD方法。 HTTP/1.1 新增了五种请求方法：OPTIONS, TRACE和CONNECT方法。 get：这种方法是将信息存储在url中，既不安全，还无法传递太大的数据。 post：向指定的路径提交数据进行处理请求，一般用于表单的提交数据。 注意：数据包含在请求体中。post请求可能会导致新的资源或以有的资源被修改。 注意:这一方法可以不必传输整个响应内用的情况下，就可以获取包含在响应消息头中的原信息。 put：从客户端向服务器传送的数据取代指定的文档内容。 delete：请求服务器删除指定的页面 head：与get请求相似的响应，但是请求体不会被返回。 options：返回服务器针对特定资源所支持的http请求方法。 options用于什么场景 preflighted request在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 由于在真正访问资源前需要发送一个请求进行探测，因此该请求被称为是Preflight Request。 【tips】：preflighted request见第三章第3节：跨域问题 trace：返回显示服务收到的请求，主要用于测试或诊断 connect：http/1.1协议中预留给能够将链接改为管道方式的代理服务 2.2、 get与post请求的区别 区别内容 GET POST 点击返回/刷新按钮 没有影响 数据会重新发送（浏览器将会提示“数据被重新提交”） 缓存 可以 不可以 历史记录 有 没有 长度限制 有 没有 安全性 查询字符串会显示在地址栏的 URL 上，不安全，请不要使用 GET 请求提交敏感数据 因为数据不会显示在地址栏中，也不会缓存下来或保存在浏览记录中，所以 POST 请求比 GET 请求安全，但也不是最安全的方式，如需要传送敏感数据，请使用数据加密。 可见性 查询字符串在地址栏的 URL 中可见 查询字符串在地址栏的 URL 中不可见 数据类型限制 只允许 ASCLll 字符类型 没有限制，允许二进制数据 添加书签 可以 不可以 get会产生一个tcp数据包，post两个。 具体就是： get请求时，浏览器会把headers和data一起发送出去，服务器响应200（返回数据） post请求时，浏览器先发送headers，服务器响应100continue，浏览器再发送data，服务器响应200（返回数据）。 这里的区别是 specification（规范）层面，而不是 implementation（对规范的实现） 3、常见的http状态码 状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 100 客户必须继续发出请求 101 客户要求服务器根据请求转换HTTP协议版本 2xx：成功–表示请求已被成功接收、处理 200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 3xx：重定向–要完成请求必须进行更进一步的操作。 300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 304（使用缓存）自从上次请求后，请求的网页未修改过，请客户端使用本地缓存 4xx：客户端错误–请求有语法错误或请求无法实现。 400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 资源未找到 5xx：服务器端错误–服务器未能实现合法的请求。 500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 4、http/1.1相比http/1.0有什么优点 增加持久性连接 也就是多个请求和响应可以利用同一个 TCP 连接，而不是每一次请求响应都要新建一个TCP连接，减少了建立和关闭连接的消耗和延迟。 响应头部中设置Connection: keep-alive 增加管道机制 增加了管道机制，请求可以同时发出，但是响应必须按照请求发出的顺序依次返回，性能在一定程度上得到了改善。 分块传输 在 HTTP/1.1 版本中，可以不必等待数据完全处理完毕再返回，服务器产生部分数据，那么就发送部分数据 发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。 增加 host 字段 HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。此外，服务器应该接受以绝对路径标记的资源请求。 错误提示 HTTP/1.1 引入了一个 Warning 头域，增加对错误或警告信息的描述，此外，在 HTTP/1.1 中新增了24个状态响应码(100，101，203，205，206，301，305… )。 带宽优化 HTTP/1.1 加入了一个新的状态码 100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码 401（Unauthorized）；如果服务器接收此请求就回送响应码 100，客户端就可以继续发送带实体的完整请求了。 100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。 注意，HTTP/1.0 的客户端不支持 100 响应码。但可以让客户端在请求消息中加入 Expect头域，并将它的值设置为 100-continue。 5、http/2.0有哪些新特性 二进制分帧 在应用层（HTTP/2.0）和传输层（TCP or UDP）之间增加一个二进制分帧层，从而突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。 可见，虽然 HTTP/2.0 的协议和 HTTP1.x 协议之间的规范完全不同了，但是实际上 HTTP/2.0并 没有改变 HTTP1.x 的语义。 简单来说，HTTP/2.0 只是把原来 HTTP1.x 的 header 和 body 部分用 frame 重新封装了一层而已。 多路复用（连接共享） 允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，这个强大的功能则是基于“二进制分帧”的特性。 从图中可见，所有的 HTTP/2.0 通信都在一个 TCP 连接上完成，这个连接可以承载任意数量的双向数据流。 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装。 首部压缩 HTTP1.1 不支持 header 数据的压缩，HTTP/2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。高效的压缩算法可以很大的压缩 header ，减少发送包的数量从而降低延迟。 服务器推送 在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应，即服务器可以额外的向客户端推送资源，而无需客户端明确的请求。 6、简述https工作原理 6.1、https协议概念 HTTP协议：一种使用明文数据传输的网络协议。 HTTPS协议：可以理解为HTTP协议的升级，就是在HTTP的基础上增加了数据加密和身份认证。在数据进行传输之前，对数据进行加密，然后再发送到服务器。这样，就算数据被第三者所截获，但是由于数据是加密的，所以你的个人信息仍然是安全的。这就是HTTP和HTTPS的最大区别。 HTTPS就是HTTP 加上数据加密处理和身份认证以及完整性校验。 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，利用对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 6.2、https工作原理 证书验证阶段 （1）浏览器发起 HTTPS 请求 浏览器里面输入一个HTTPS网址，然后连接到服务端的443端口上。注意这个过程中客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单。 （2）服务端返回 HTTPS 证书 采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。 这套证书其实就是一对公钥和私钥。可以这么理解，公钥就是一把锁头，私钥就是这把锁的钥匙，锁头可以给别人对某个东西进行加锁，但是加锁完毕之后，只有持有这把锁的钥匙才可以解锁看到加锁的内容。 返回的证书还包含了很多信息，如证书的颁发机构、过期时间等等。 服务器从报文文本生成一个128位的散列值（hash值），发送方使用自己的私钥对这个散列值进行加密形成数字签名 （3）客户端验证证书是否合法，如果不合法则提示告警；验证合法则在本地生成随机数，通过公钥加密随机数，并把加密后的随机数传输到服务端 这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，如证书的颁发机构CA、证书的有效期、公钥、证书所有者、签名等等，如果发现异常则会弹出一个警告框，提示证书存在问题。 如果证书没有问题，浏览器使用相同的hash算法计算出服务器发来的原始报文（证书）的hash值，再用服务器发来的公钥对证书里面的数字签名进行解密，将计算的hash值与签名做对比，对比结果一致，则证明服务器发来的证书合法，没有被冒充，此时浏览器就可以读取证书中的公钥，用于后续加密了。 那么就生成一个随机值（会话密钥），然后用公钥对该随机值进行加密，然后返回给服务端。 注意一下上面提到的\"发现异常\"。证书中会包含数字签名，该数字签名是加密过的，是用颁发机构的私钥对本证书的公钥、名称及其他信息做hash散列加密而生成的。客户端浏览器会首先找到该证书的根证书颁发机构，如果有，则用该根证书的公钥解密服务器下发的证书，如果不能正常解密，则就是\"发现异常\"，说明该证书是伪造的。 （4）服务端通过私钥对随机数（会话密钥）进行解密 服务端用私钥解密后，得到了客户端传过来的随机值（会话密钥），至此一个非对称加密的过程结束，看到TLS利用非对称加密实现了身份认证和密钥协商，然后把内容通过该值进行对称加密。 数据传输阶段 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输 客户端用之前生成的随机值解密服务端传送过来的信息，于是获取了解密后的内容，至此一个对称加密的过程结束，看到对称加密是用于对服务器待传送给客户端的数据进行加密用的。整个过程即使第三方监听了数据，也束手无策。 6.3、HTTP 和 HTTPS 的区别 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。 7、TCP协议 7.1、tcp协议概念 Tcp位于传输层， 提供可靠的字节流服务。所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。 即TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。所以，TCP连接相当于两根管道（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，传输是有序的，每个字节都是一个一个来传输。 7.2、三次握手和四次挥手 三次握手 第一次握手：建立连接时，客户端A发送SYN包（SYN，seq=x）到服务器B，并进入SYN_SEND状态，等待服务器B确认 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=x+1），同时自己也发送一个SYN包（SYN，seq=y），即SYN+ACK包，此时服务器B进入SYN_RECV状态 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=y+1），此包发送完毕，完成三次握手 四次挥手 客户端A发送一个FIN（FIN=1，seq=n），用来关闭客户A到服务器B的数据传送 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（ACK=n+1） 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（FIN=1，seq=m） 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（ACK=m+1） 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接**。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。先进行关闭的一方将执行主动关闭，而另一方被动关闭。 7.3、TCP和UDP区别 TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）； UDP提供无连接的传输，通信前不需要建立连接。 TCP提供可靠的传输（有序，无差错，不丢失，不重复）； UDP提供不可靠的传输。 TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组； UDP是面向数据报的传输，没有分组开销。 TCP提供拥塞控制和流量控制机制； UDP不提供拥塞控制和流量控制机制。 7.4、扩展 【问题1】为什么连接的时候是三次握手，关闭的时候却是四次挥手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\"你发的FIN报文我收到了\"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次握手。 【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假设网络是不可靠的，有的话可能会导致最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。Server发出FIN之后，如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 MSL的定义，MSL是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长的最长时间，超过这个时间报文将被丢弃。 【问题3】为什么不能用两次握手进行连接？ 三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，可能发生死锁。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 8、什么是CDN CDN就是内容分发网络，加速网络传输，就是通过将资源部署到世界各地，用户访问时按照就近原则从最近的服务器获取资源，从而提高获取资源的速度。 CDN加速意思就是在用户和服务器之间加一个缓存机制，通过这个缓存机制可以动态的获取IP地址根据地理位置，让用户到最近的服务器访问。 CDN系统能实时的根据网络流量和各节点的连接，负载状况及用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，其目的是使用户能就近的获取请求数据，解决网络拥堵，提高访问速度，解决由于网络带宽小，用户访问量大，网点分布不均等原因导致的访问速度慢的问题。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 安全","keywords":"","body":"第五章 安全 1、XSS攻击 2、CSRF攻击 1、XSS攻击 1.1、XSS 攻击是什么 XSS 攻击(Cross Site Scripting，跨站脚本攻击)：它是通过对网页注入可执行的恶意脚本且成功地被浏览器 执行，从而达到攻击的目的，例如获取用户的敏感信息如 Cookie/SessionID、导航到恶意网站、携带木马等，进而危害数据安全。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 例如，当一个form表单中来自用户的输入变成 \"/>alert(document.cookie) alert(document.cookie) 事件被触发的时候嵌入的JavaScript代码将会被执行。 用户是通过哪种方法“注入”恶意脚本的呢？ 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） 1.2、XSS攻击方式 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型XSS 攻击 反射型XSS，也叫非持久型XSS 这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。 从概念上可以看出，反射型XSS代码是首先出现在URL中的，作为参数提交到服务器，然后需要服务端解析并响应，最后需要浏览器解析之后XSS代码才能够攻击。 总结来说，就是恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。 存储型XSS攻击 存储型 XSS 会把用户输入的数据 \"存储\" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 存储型 XSS 将恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上。 DOM型xss攻击 基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。 （1）攻击者构造出特殊的 URL，其中包含恶意代码。 （2）用户打开带有恶意代码的 URL。 （3）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 （4）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 1.3 XSS漏洞修复 攻击防范 HttpOnly 防止劫取 Cookie HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。 攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。 输入检查（XSS Filter） 对于用户的任何输入要进行检查、过滤和转义。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。 在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。 2、CSRF攻击 2.1、CSRF攻击是什么 CSRF（Cross-site request forgery），跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。 你这可以这么理解CSRF攻击：攻击者盗用了用户的身份，以该用户的名义发送恶意请求。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。 完成一次CSRF攻击，受害者必须依次完成两个步骤： 　　1.登录受信任网站A，并在本地生成Cookie。 　　2.在不退出A的情况下，访问危险网站B。 CSRF攻击的本质原因：源于Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF攻击的一般是由服务端解决。 2.1、CSRF防御 2.2.1、验证 HTTP Referer 字段 根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。 例如：https://github.com/zbcwilliam/zhihu_spider 是从简书地址https://www.jianshu.com/p/1007e8b26338跳转过来的，那么在打开上述git地址时，请求头中的**Referer字段**: https://www.jianshu.com/go-wild?ac=2&url=https%3A%2F%2Fgithub.com%2Fzbcwilliam%2Fzhihu_spider，就可以表明这是一个由外部地址跳转过来的不可信任地址。 因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。 这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。 缺点：对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。即便是使用最新的浏览器，黑客无法篡改 Referer 值，用户自己也可以设置浏览器使其在发送请求时不再提供 Referer。 2.2.2、 在请求地址中添加 token 并验证 CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。 2.2.3、 浏览器Cookie策略 IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。 PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。 PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。 2.2.4、 加验证码 验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。 2.2.5、 Referer Check Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。 但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。 2.2.6、 Anti CSRF Token 现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。 例子： 用户访问某个表单页面。 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。 在页面表单附带上Token参数。 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。 这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。 注意： CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。 二者对比：CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。 【参考】 前端安全系列（一）：如何防止XSS攻击 CSRF 攻击的应对之道 浅说 XSS 和 CSRF Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-28 17:11:11 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 性能","keywords":"","body":"第六章 性能 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter7/":{"url":"Chapter7/","title":"第七章 React&rRedux","keywords":"","body":"第七章 React&rRedux 第1节：React基础篇 第2节：React进阶篇 第3节：Redux Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-27 14:56:58 "},"Chapter7/React基础篇.html":{"url":"Chapter7/React基础篇.html","title":"第1节：React基础篇","keywords":"","body":"第1节：React基础篇 1、react生命周期 2、react15和16的生命周期函数有什么变化？ 3、getDerivedStateFromProps怎样使用 4、列表组件中写 key的作用是什么？ 5、组件更新 6、组件通信 1、react生命周期 1.1、组件初始化(initialization)阶段 也就是以下代码中类的构造方法( constructor() )，声明的组件继承了react Component这个基类，才能有render()，生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。 super(props)用来调用基类的构造方法( constructor() )，实际上就是调用parents.call(this)，也将父组件的props注入给子组件，供子组件读取(组件中props只读不可变，state可变)。 constructor()常用来做一些组件的初始化工作，如定义this.state的初始内容。 1.2、组件挂载(Mounting)阶段 此阶段分为componentWillMount，render，componentDidMount三个时期 componentWillMount 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。 render 根据组件的props和state，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。 render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。 componentDidMount 组件挂载到DOM后调用，且只会被调用一次，一般用于进行异步请求、起定时器或者进行事件订阅。 1.3、组件更新(update)阶段 此阶段分为componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate。 componentWillReceiveProps(nextProps) 此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState触发当前组件的重新render shouldComponentUpdate(nextProps, nextState) 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。 ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。 componentWillUpdate(nextProps, nextState) 此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。 render componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state 1.4、组件卸载(UnMounting)阶段 此阶段只有一个生命周期方法：componentWillUnmount 此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器，清除componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。 2、react15和16的生命周期函数有什么变化？ 16中引入了React Fiber的概念。 React Fiber一个更新过程被分为两个阶段(Phase)：第一个阶段Reconciliation Phase和第二阶段Commit Phase。 在第一阶段Reconciliation Phase，React Fiber会找出需要更新哪些DOM，这个阶段是可以被打断的；但是到了第二阶段Commit Phase，那就一鼓作气把DOM更新完，绝不会被打断。 这两个阶段大部分工作都是React Fiber做，和我们相关的也就是生命周期函数。 以render函数为界，第一阶段可能会调用下面这些生命周期函数，说是“可能会调用”是因为不同生命周期调用的函数不同。 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数（也就是第一阶段的函数），都有可能被执行多次。 原来（React v16.0前）的生命周期有哪些是在render前执行的呢？ componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。这明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。 禁止不能用比劝导开发者不要这样用的效果更好，所以除了shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被打上了UNSAFE的标记，从而被新的生命周期函数所取代。 新增的生命周期函数如下： static getDerivedStateFromProps(nextProps, prevState) // 也就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state。 getSnapshotBeforeUpdate(prevProps, prevState) componentDidCatch(error, info) static getDerivedStateFromProps 和 componentWillReceiveProps 的显著区别 触发机制: UNSAFE_componentWillReceiveProps(nextProps) 在组件接收到新的参数时被触发。 当父组件导致子组件更新的时候, 即使接收的 props 并没有变化，这个函数也会被调用。 getDerivedStateFromProps(props, state) 会在每次组件渲染前被调用。 getDerivedStateFromProps 会在每次组件被重新渲染前被调用，这意味着无论是1、父组件的更新，2、props 的变化，3、组件内部执行了 setState(), 它都会被调用. 工作方式 UNSAFE_componentWillReceiveProps(nextProps)：参数是组件接收到的新的 props ，用于比对新的 props 和原有的 props，用户需要在函数体中调用 setState() 来更新组件的数据。 static getDerivedStateFromProps(nextProps, currentState)：参数是组件接收到的新的 props 和组件当前的数据. 用户需要在这个函数中返回一个对象, 它将作为 setState() 中的 Updater 更新组件。 3、getDerivedStateFromProps怎样使用 让表单控件变成完全受控组件, 不论是 onChange 处理函数还是 value 都由父组件控制, 这样用户无需再考虑这个组件 props 的变化和 state 的更新. function EmailInput(props) { return ; } 让表单控件变成完全不受控组件, 但是具有 key 属性. 仍然用自身的数据来控制 value. 但是接收 props 中的某个字段作为 key 属性的值, 以此响应 props 的更新: 当 key 的值变化时 React 会重置 (reset)组件，从而重新生成初始化数据. 如下例中，实际上达到的效果就是props中的user.id改变，email的value就改变： class EmailInput extends Component { state = { email: this.props.defaultEmail }; handleChange = event => { this.setState({ email: event.target.value }); }; render() { return ; } } // 在父组件中接收 props 中的数据作为 key 4、列表组件中写 key的作用是什么？ react利用key来识别组件，有了key属性后，就可以与组件建立一种对应关系，react根据key来决定是销毁重新创建组件还是更新组件。 key相同，若组件属性有所变化，则react只更新组件对应的属性；没有变化则不更新。 key值不同，则react先销毁该组件(有状态组件的componentWillUnmount会执行)，然后重新创建该组件（有状态组件的constructor和componentWillUnmount都会执行） key取值原则： key值在同级同类型的组件上要保持唯一 尽量不要用数组的index去作为key 主要从以下两个方面考虑 --错误处理组件更新： 当我们对数据进行逆序等操作时，index和组件的对应关系就不再和之前一致，这种情况下diff算法对新老集合进行差异检测，就无法发现key值有变化然后重新渲染 --性能： 当我们对数据有删除、添加等操作时。我们所遍历的index，就会有所变化，这种情况下diff算法对新老集合进行差异检测，发现key值有变化然后就会重新渲染， 我们只需要乖乖的把id（或者其他唯一标识）作为key，这样就只会对key值有变化的进行重绘，就可以解决这种性能问题了。 不要试图在render的时候用随机数或者其他操作给元素加上不稳定的key，这样造成的性能开销比不加key的情况下更糟糕 5、组件更新 造成组件更新有以下几种情况： 5.1、父组件重新render引起子组件重新render 父组件重新render引起子组件重新render的情况有两种： 直接使用，每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化（或无论是否传了props） 这种方式，父组件改变props后，子组件重新渲染，由于直接使用的props，所以我们不需要做什么就可以正常显示最新的props class Child extends Component { render() { return {this.props.someThings} } } 可通过shouldComponentUpdate方法优化： class Child extends Component { shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染 if(nextProps.someThings === this.props.someThings) { return false } } render() { return {this.props.someThings} } } 将props转换成自己的state 这种方式，由于我们使用的是state，所以每当父组件每次重新传递props时，我们需要重新处理下，将props转换成自己的state，这里就用到了 componentWillReceiveProps。 每次子组件接收到新的props，都会重新渲染一次，除非你做了处理来阻止（比如使用：shouldComponentUpdate），但是你可以在这次渲染前，根据新的props更新state，更新state也会触发一次重新渲染，但react不会这么傻，所以只会渲染一次，这对应用的性能是有利的。 class Child extends Component { constructor(props) { super(props); this.state = { someThings: props.someThings }; } componentWillReceiveProps(nextProps) { this.setState({someThings: nextProps.someThings}); } render() { return {this.state.someThings} } } class Child extends Component { constructor(props) { super(props); this.state = { someThings: props.someThings }; } componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法 this.setState({someThings: nextProps.someThings}); } render() { return {this.state.someThings} } } 是因为componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了。 React16中新的生命周期函数被引入了, 即静态方法 getDerivedStateFromProps，来取代componentWillReceiveProps 5.2、组件本身调用setState 可通过shouldComponentUpdate方法优化 class Child extends Component { constructor(props) { super(props); this.state = { someThings:1 } } shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染 if(nextStates.someThings === this.state.someThings){ return false } } handleClick = () => { // 虽然调用了setState ，但state并无变化 const preSomeThings = this.state.someThings this.setState({ someThings: preSomeThings }) } render() { return {this.state.someThings} } } 扩展 【state和props作用和区别】 props是一个从外部传进组件的参数，主要作用就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。 6、组件通信 6.1、父组件向子组件通信 在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。 6.2、子组件向父组件通信 利用回调函数 利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。 利用自定义事件机制 6.3、跨级组件通信 所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式： 中间组件层层传递 props 使用 context 对象 扩展 【 context 】 如果要Context发挥作用，需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。 对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。 import React, { Component } from 'react' import PropTypes from 'prop-types' class ParentComponent extends Component { // 声明Context对象属性 static childContextTypes = { propA: PropTypes.string, methodA: PropTypes.func } // 返回Context对象，方法名是约定好的 getChildContext () { return { propA: 'A', methodA: () => { console.log('hello, world') } } } render () { return } } class MiddleComponent extends Component { render () { return } } class ChildComponent extends Component { // 子组件需要通过一个静态属性contextTypes声明后，才能访问父组件Context对象的属性，否则，即使属性名没写错，拿到的对象也是undefined static contextTypes = { propA: PropTypes.string, methodA: PropTypes.func } render () { const { propA, methodA } = this.context methodA() return ({propA}) } } 对于无状态子组件(Stateless Component)，可以通过如下方式访问父组件的Context const ChildComponent = (props, context) => { const { propA } = context return ({propA}) } 事实上，很多优秀的React组件都通过Context来完成自己的功能，比如react-redux，就是通过Context提供一个全局态的store，拖拽组件react-dnd，通过Context在组件中分发DOM的Drag和Drop事件，路由组件react-router通过Context管理路由状态等等。在React组件开发中，如果用好Context，可以让你的组件变得强大，而且灵活。 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter7/React进阶篇.html":{"url":"Chapter7/React进阶篇.html","title":"第2节：React进阶篇","keywords":"","body":"第2节：React进阶篇 1、虚拟dom 2、diff算法 3、setState 4、react事件和原生事件 5、高阶组件 1、react生命周期 1.1、概念 虚拟DOM就是一个JavaScript 对象，包含了 tag、props、children 三个属性。 虚拟DOM能够提高渲染的性能，数据与UI分离，并且有利于服务器渲染。 hello world!!! 上面的 HTML 转换为虚拟 DOM 如下： { tag: 'div', props: { id: 'app' }, chidren: [ { tag: 'p', props: { className: 'text' }, chidren: [ 'hello world!!!' ] } ] } virtual dom 基本步骤 ①用JS对象构建一颗虚拟DOM树，然后用虚拟树构建一颗真实的DOM树，然后插入到文档中。 ②当状态变更时，重新构造一颗新的对象树，然后新树旧树进行比较，记录两树差异。 ③把步骤2的差异部分应用到构建的真实DOM树上，视图就更新了。 1.2、为什么需要虚拟DOM 前端性能优化的一个很重要的点就是尽可能少地操作DOM，不仅仅是DOM相对较慢，更因为频繁变动DOM会造成浏览器的回流或者重绘，因此需要这一层抽象，在patch过程中尽可能地一次性将差异更新到DOM中，从而保证了DOM性能。 1.3、虚拟DOM 性能 直接操作 DOM 的性能并不会低于虚拟 DOM 和 Diff 算法，甚至还会优于。 这么说的原因是因为 Diff 算法的比较过程，比较是为了找出不同从而有的放矢的更新页面。但是比较也是要消耗性能的。而直接操作 DOM 就是有的放矢，我们知道该更新什么不该更新什么，所以不需要有比较的过程。所以直接操作 DOM 效率可能更高。 那么为什么还需要虚拟DOM 呢？ 虚拟 DOM 和 Diff 算法的出现是为了解决由命令式编程转变为声明式编程、数据驱动后所带来的性能问题。 DOM 发生变化的时候，通过 diff 算法比对 JavaScript 原生对象，计算出需要变更的 DOM，然后只对变化的 DOM 进行操作，而不是更新整个视图。 1.4、渲染虚拟DOM function render(vdom) { // 如果是字符串或者数字，创建一个文本节点 if (typeof vdom === 'string' || typeof vdom === 'number') { return document.createTextNode(vdom) } const { tag, props, children } = vdom // 创建真实DOM const element = document.createElement(tag) // 设置属性 setProps(element, props) // 遍历子节点，并获取创建真实DOM，插入到当前节点 children .map(render) .forEach(element.appendChild.bind(element)) // 虚拟 DOM 中缓存真实 DOM 节点 vdom.dom = element // 返回 DOM 节点 return element } function setProps (element, props) { Object.entries(props).forEach(([key, value]) => { setProp(element, key, value) }) } function setProp (element, key, vlaue) { element.setAttribute( // className使用class代替 key === 'className' ? 'class' : key, vlaue ) } 将虚拟 DOM 渲染成真实 DOM 后，只需要插入到对应的根节点即可 class Component { vdom = null // 组件的虚拟DOM表示 $el = null // 虚拟DOM生成的真实节点 state = { text: 'Initialize the Component' } render() { const { text } = this.state return ( { text } ) } } function createElement (root, component) { const vdom = component.render() component.vdom = vdom component.$el = render(vdom) // 将虚拟 DOM 转换为真实 DOM root.appendChild(component.$el) } const root = document.getElementById('root') const component = new Component() createElement(root, component) 2、diff算法 2.1、概念 diff 算法，顾名思义，就是比对新老 VDOM 的变化，然后将变化的部分更新到视图上。对应到代码上，就是一个 diff 函数，返回一个 patches （补丁）。 2.2、React diff 三大策略 策略一（tree diff） Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。（DOM结构发生改变-----直接卸载并重新creat） React的做法是把dom tree分层级，对于两个dom tree只比较同一层次的节点，忽略Dom中节点跨层级移动操作，只对同一个父节点下的所有的子节点进行比较。如果对比发现该父节点不存在则直接删除该节点下所有子节点，不会做进一步比较，这样只需要对dom tree进行一次遍历就完成了两个tree的比较。 策略二（component diff） DOM结构一样-----不会卸载，但是会update 对于同一类型组件合理使用shouldComponentUpdate（），应该避免结构相同类型不同的组件 策略三（element diff） 所有同一层级的子节点，他们都可以通过key来区分-----同时遵循1.2两点 React会先进行新集合遍历，for(name in nextChildren)，通过key值判断两个对比集合中是否存在相同的节点，即if(prevChild === nextChild)，如何为true则进行移动操作 3、setState 3.1、setState做了什么 调用了setstate之后，react会将传入的参数对象与组件当前的状态做合并，然后触发调和过程，react会根据新的状态构建react元素树，并重新渲染整个UI界面。 react得到元素树之后，react会自动计算出新树与老树节点的差异，然后根据差异对界面进行最小化重渲染 3.2、关于setState的异步问题 setState 不会立刻改变React组件中state的值，他通过触发一次组件的更新来引发重绘，多次 setState 函数调用产生的效果会合并，然后一次引发更新过程，为的就是把 Virtual DOM 和 DOM 树操作降到最小，用于提高性能。 setState 通过 batchingStrategy，也就是批量更新策略来完成一次更新，isBatchingUpdates则是用来标志批量更新的标志位，通过它判断是直接更新 this.state还是放到队列中，默认是false，也就表示setState会同步更新this.state；如果为true就放到队列中，异步更新。 组件生命周期中的异步更新 例如，在componentDidMount中调用setState并不会立即更新state，因为正处于一个更新流程中，isBatchingUpdates为true，所以只会放入dirtyComponents中等待稍后更新。 react事件中的异步更新 由React引发的事件处理（比如通过onClick引发的事件处理），调用 setState 只能异步更新 this.state。 React在调用事件处理函数之前就会把isBatchingUpdates置为true，因此由React控制的事件处理过程setState不会同步更新this.state。 3.3、扩展 下面这个例子，企图通过点击事件之后就使用修改之后的state的值，但是会发state中的并没有被立即修改，还是原先的值，我们都知道那是因为setState就相当于是一个异步操作，不能立即被修改。 handleClick = () => { this.setState({ count: this.state.count + 1 }) console.log('count', this.state.count) } 解决方法： 利用setState第二个参数（传入一个函数），该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成 handleClick = () => { this.setState({ count: this.state.count + 1 }, () => { console.log('count', this.state.count) }) } async&await handleClick = async () => { await this.setState({ count: this.state.count + 1 }) console.log('count', this.state.count) } 3.4、setState 什么时候会执行同步更新？ 在React中，如果是由React引发的事件处理（比如通过onClick引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的setState调用会同步执行this.state。 所谓“除此之外”，指的是绕过React通过 addEventListener 直接添加的事件处理函数，还有通过setTimeout或setInterval 产生的异步调用。 简单一点说， 就是经过React 处理的事件是不会同步更新this.state的。通过addEventListener、setTimeout、setInterval的方式处理的则会同步更新。 4、react事件和原生事件 4.1、React合成事件机制 React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）。 当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行，这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。 React 中的event 不是原生的event，e.nativeEvent 才是原生 DOM 事件的那个 event。 4.2、React合成事件有哪些 鼠标事件 onClick onDoubleClick onMouseDown onMouseUp onMouseEnter onMouseLeave onMouseMove 拖拽事件 Drop onDrag 键盘事件 onKeyPress onKeyDown onKeyUp 焦点事件 onFocus onBlur 表单事件 onChange onSubmit 4.3、React合成事件的事件流和事件委托 事件流 React中，默认的事件传播方式为冒泡 如果希望以捕获的方式来触发事件的话，可以使用onClickCapture来绑定事件，也就是在事件类型后面加一个后缀Capture 事件委托 在合成事件系统中，事件没有在目标对象上绑定，所有的事件都是绑定在document元素上。 react会在内部维护一个映射表记录事件与组件事件处理函数的对应关系 当某个事件触发时，React根据这个内部映射表将事件分派给指定的事件处理函数 当一个组件安装或者卸载时，相应的事件处理函数会自动被添加到事件监听器的内部映射表中或从表中删除 4.4、一些处理 阻止默认行为 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为，明确的使用 preventDefault。 阻止冒泡 用reactEvent.nativeEvent.stopPropagation()来阻止冒泡是不行的。 阻止 React 事件冒泡的行为只能用于 React 合成事件系统中，且没办法阻止原生事件的冒泡。反之，在原生事件中的阻止冒泡行为，却可以阻止 React 合成事件的传播。 componentDidMount() { document.getElementById('li').addEventListener('click', this.onDomLiClick, false) document.getElementById('ul').addEventListener('click', this.onDomUlClick, false) } onDomLiClick(e: any) { // 事件委托 // e.stopPropagation() console.log('Li Dom click') } onDomUlClick(e: any) { console.log('Ul Dom click') } onReactUlClick() { // react合成事件 console.log('React Ul click'); } onReactLiClick(e: any) { // react合成事件 e.stopPropagation() console.log('React Li click'); } zhaoshanshan 5、高阶组件 5.1、什么是高阶组件 高阶组件:高阶组件是一个函数，它接受一个组件作为参数，返回一个新的组件 高阶组件通过包裹（wrapped）被传入的React组件，经过一系列处理，最终返回一个相对增强（enhanced）的React组件，供其他组件调用。 高阶组件让我们的代码更具有复用性, 逻辑性与抽象性 它可以对render方法做挟持, 也可以控制props和state --高阶组件的两种形式 属性代理：高阶组件通过包裹的React组件来操作props 反向继承：高阶组件继承于被包裹的React组件 （待完成） https://axiu.me/coding/react-batchedupdates-and-transaction/ Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter7/Redux.html":{"url":"Chapter7/Redux.html","title":"第3节：Redux","keywords":"","body":"第3节：Redux 1、redux机制 2、react-redux 1、redux机制 1.1、什么是redux Redux是一个流行的JavaScript框架，为应用程序提供一个可预测的状态容器。Redux基于简化版本的Flux框架，Flux是Facebook开发的一个框架。 在Redux中，所有的数据（比如state）被保存在一个被称为store的容器中（一个应用程序中只能有一个store）。store本质上是一个状态树，保存了所有对象的状态。任何UI组件都可以直接从store访问特定对象的状态。想要更改状态，需要分发一个action（分发在这里意味着将可执行信息发送到store）。当store接收到action后，会把这个action代理给相关的reducer。reducer是一个纯函数，它通过action.type执行对应action并且返回一个新的状态。 使用Redux的主要优势之一是它可以帮你处理应用的共享状态。如果两个组件需要访问同一状态，该怎么办？这种两个组件同时需要访问同一状态的现象称为“共享状态”。你可以将该状态提升到附近的父组件，但是如果该父组件在组件树中向上好几个组件的位置，那么将状态当做属性向下一个一个地传递，很容易就会使组件的状态变得混乱且难以管理。 1.2、redux的三大原则 单一数据源 Redux的基本原则之一是存在单一数据源：Store。也就是说，所有状态全部存储在一个对象树store中。 只有单个状态树，对于应用的很多方面都有好处。假设在构建应用时尝试实现撤消/重做功能，如果所有状态都存储在一个树（单一数据源）中，则实现起来比数据分散在多个组件中简单多了。状态集中到一个位置后，调试和检测过程也会简单很多。 State 只读 唯一改变 state的方法就是触发action，action是一个用于描述发生事件(动作)的对象。 这样设计的好处是： 增强了可预测性和可靠性 避免产生副作用 阻止外部文件修改state 所有对state的改动都被集中于一个地方，并且被严格地依次触发 更改state的唯一方式是派发相应的action，以描述所需的更改 使用纯函数来执行修改 为了描述action如何改变state tree ，你需要编写reducers，他是一个纯函数，在这里进行一系列处理并返回一个新的state。 1.3、纯函数 纯函数 纯函数是 Redux 应用中，更新状态的必要手段。纯函数的定义是: 对于同一参数，返回同一结果 该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态或在程序的两个不同的执行 输出完全取决于传入的参数 不会产生副作用 纯函数的条件之一是不产生副作用 副作用是指函数对其外部世界产生影响，包括： 发出 HTTP 调用 改变外部状态 检索今天的日期 Math.random() 向控制台输出消息 向数据库中添加数据 纯函数优点： 纯函数本质上就是模块化的，这使它更容易被测试。由于当参数相同时，纯函数总是产⽣相同的结果，你不必担⼼应用其他部分的数据受到影响。在调试期间，这将给予明确定义的额外控制点。 纯函数使代码更好维护。纯函数不会产生副作用。这意味着你在重构应用时，纯函数不会对其外部内容产生任何不利影响。 2、react-redux 2.1、react-redux 解决的问题 负责应用的状态管理，保证单向数据流 监听状态，在数据发生改变时，执行预期的操作 2.2、react-redux原理分析 react-redux 的使用分为两步： 第一步：使用 Provider 在顶层创建一个 Root 节点，将创建的 store 作为 Provider 的 props 传入 第二步：在需要使用 store 的页面，使用 connect 将组件与 store 建立连接关系，需要用到的值通过 mapStateToProps 传入对应的组件中 Provider 首先在最外层容器中，把所有内容包裹在Provider组件中，将之前创建的store作为prop传给Provider。 Provider接收redux的createStore()的结果，并且放到context里，让子组件可以通过context属性直接获取到这个createStore的结果。 const store = createStore(combineReducers, {}) const App = () => { return ( ) } createStore返回的结果内容如下： return { //真正的返回，执行createStore其实返回的就是这些东东 dispatch, //触发action去执行reducer，更新state subscribe, //订阅state改变，state改变时会执行subscribe的参数（自己定义的一个函数） getState, //获取state树 replaceReducer, //替换reducer } Connect connect接收到mapStateToProps，会在内部subscribe全局state的改变，来判断props是否更改，如果需要更新，才触发更新。 一个基础的connect方法如下： connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) mapStateToProps：传入所有state，返回指定的state数据 mapDispatchToProps：传入dispatch，返回action方法 通过connect这个高阶组件包裹的对象组件，可以访问到定制化的数据或者方法，并且无需自己去subscribe全局state的变化，当state变化时，所有被connect包裹的对象组件都会被一次触发更新。 一个connect高阶组件的简单实现： export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => { class Connect extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { allProps: {} } } componentWillMount () { const { store } = this.context this._updateProps() store.subscribe(() => this._updateProps()) // 通过subscribe订阅state的变化，state改变时会执行subscribe传入的入参函数 } _updateProps () { const { store } = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : {} // 防止 mapStateToProps 没有传入 let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : {} // 防止 mapDispatchToProps 没有传入 this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props } }) } render () { return } } return Connect } 可以看出，在connect这个高阶组件中，我们通过context拿到store对象，然后给一个_updateProps的更新函数，这个更新函数中将connect入参mapStateToProps和mapDispatchToProps去做setState更新，然后做为props注入目标组件。 由于这个_updateProps不光会在componentWillMount执行一次，同时也会做为subscribe的入参，subscribe能够订阅state的改变，因此后续有state发生变化时，订阅过的组件（也就是被connect包裹的组件）都会被触发更新。 middleware redux工作的整个过程都是同步的，只要action被dispatch到reducer，对应state发生变化，UI就立即更新。 如果dispatch一个action之后，到达reducer之前，进行一些额外的操作，就需要用到middleware。你可以利用 Redux middleware 来进行日志记录、创建崩溃报告、调用异步接口或者路由等等。 换言之，中间件都是对store.dispatch()的增强。 import { applyMiddleware, createStore } from 'redux'; import thunk from 'redux-thunk'; const store = createStore( reducer, applyMiddleware(thunk) ) 中间件都要放到applyMiddleware里，如果要添加中间件，可以依次添加，但是要遵循文档定义的顺序。 createStore其实可以接受三个参数，第二个参数preloadedState一般作为整个应用的初始化数据，如果传入了这个参数，applyMiddleware就会被当做第三个参数处理。 上述代码中applyMiddleware的入参thunk是一个包裹着一个表达式以延迟其求值的函数，他可以用来延迟dispatch一个action或者只在某些特定场景下才dispatch。 在我们没有加上thunk这个中间件之前，store的dispatch方法只能传入一个action对象，thunk的作用就是能够让我们可以将一个function方法传入diptach，这在做异步的时候非常有用。 const login = (userName) => (dispatch) => { request.post('/api/login', { data: userName }, () => { dispatch({ type: 'loginSuccess', payload: userName }) }) } 【扩展】 applyMiddleware源代码 export default function applyMiddleware(...middlewares) { return (createStore) => (reducer, preloadedState, enhancer) => { var store = createStore(reducer, preloadedState, enhancer); var dispatch = store.dispatch; var chain = []; var middlewareAPI = { getState: store.getState, dispatch: (action) => dispatch(action) }; chain = middlewares.map(middleware => middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return {...store, dispatch} } } 从源代码可以看出，实现中间件的核心代码是compose，他接受多个函数做为参数，并返回一个新的函数，新的函数会从右至左依次执行原函数，并且上一个结果的返回值会做为下一个函数的参数。 compose具体实现可以参考：第一章 Javascript/第2节： 原理性实现 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter8/":{"url":"Chapter8/","title":"第八章 算法","keywords":"","body":"第八章 算法 第1节：查找 第2节：排序 第3节：一些常见的算法题目 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-28 15:47:17 "},"Chapter8/查找.html":{"url":"Chapter8/查找.html","title":"第1节：查找","keywords":"","body":"第1节：查找 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 19:56:28 "},"Chapter8/排序.html":{"url":"Chapter8/排序.html","title":"第2节：排序","keywords":"","body":"第2节：排序 1、冒泡排序 2、选择排序 3、插入排序 4、快速排序 1、冒泡排序 通过相邻元素的比较和交换，使得每一趟循环都能找到无序数组的最大值或最小值。 function bubbleSort(arr: Array) { for(let i=0, len=arr.length; i arr[j+1]) { [arr[j], arr[j+1]] = [arr[j+1], arr[j]] } } } return arr } 平均时间复杂度：O(n²) 2、选择排序 每次以既定的第一个数值为基准，遍历后面的每一个元素，比基准小则交换位置。 function selectSort(arr: Array) { for(let i=0, len=arr.length; i arr[j]) { [arr[i], arr[j]] = [arr[j], arr[i]] } } } return arr } 与冒泡排序的区别：冒泡排序是相邻两个元素比较，选择排序是选定一个数值后，与之后面元素一次进行比较。 平均时间复杂度：O(n²) 3、插入排序 以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。 function insertSort(arr: Array) { for(let i=1, len=arr.length; i = 0 && tem 平均时间复杂度：O(n²) 4、快速排序 选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。 快排实际上是分治思想在排序算法上的典型应用。 function quickSort(arr: Array) { if(arr.length middle) { right.push(arr[i]) } } return quickSort(left).concat(middle, quickSort(right)) } 上面这种做法比较浪费空间，建议使用如下实现： function quickSort(arr: Array) { // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置 function partition(arr: Array, left: number, right: number) { // 取第一个数为基数 let temp = arr[left]; while(left = temp) right--; arr[left] = arr[right]; while(left , left: number, right: number) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } return recursive(arr, 0, arr.length-1); } 平均时间复杂度：O(n * logn) Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-28 15:43:22 "},"Chapter8/一些常见的算法题目.html":{"url":"Chapter8/一些常见的算法题目.html","title":"第3节：一些常见的算法题目","keywords":"","body":"第3节：一些常见的算法题目 1、大数相加 2、找出集合所有子集 3、求两个整数最大公约数 4、使用逻辑位运算符实现相加函数 5、数字的千分位展示 6、拍平数组 7、最长公共子序列 8、最大公共子串 9、最大子数组和 10、实现类似lodash中get方法 11、字符串反转 12、判断一个字符串是否另一个字符串的子序列 13、数组中两数之和 14、数字反转 15、判断回文数字 16、删除排序数组中的重复项 17、判断一个字符串是否另一个字符串的子串 1、大数相加 将两个数字前面补0至相同的长度，然后从低位到高位进行相加， 同时用一个变量记录进位的信息即可。 function bignum(num1, num2) { let len = 0, str = '', i = 0, carried = 0 while (len 10 ? 1 : 0 str = tem % 10 + str i++ } } 2、找出集合所有子集 function subsets(nums){ var result = [[]] for(var i = 0; i 3、求两个整数最大公约数 function divisors(m, n){//辗转相除法 求最大公约数 var u = +m, v = +n, t = v while(v !== 0){ t = u % v u = v v = t } return u } 4、使用逻辑位运算符实现相加函数 function twoSum(a, b) { if (a === 0) return b if (b === 0) return a const res = a ^ b // 异或运算，计算出除去需要进位的那一部分的和 // 位与运算，计算出需要进位的地方，并且左移一位，与上数相加 return twoSum(res, (a & b) 5、数字的千分位展示 正则 function moneyFormatReg(num) { // 非获取匹配，正向肯定预查(?=pattern) return (num.toFixed(2) + '').replace(/(\\d{1,3})(?=(\\d{3})+(\\.\\d*)?$)/g, '$&,') } 非正则 function moneyFormat(num) { const res = [] num = num.toFixed(2) + '' const [intnum, decnum] = num.split(\".\") res.unshift(decnum) res.unshift('.') for(let i=1, j=intnum.length-1; j >= 0; j--, i++) { res.unshift(intnum[j]) if(i%3 === 0) { res.unshift(',') } } return res.join(\"\") } 6、拍平数组 function flat(arr) { var result = [] for(let i = 0; i 7、最长公共子序列 最长公共子序列（Longest Common Subsequence LCS）：给定序列X和Y，从它们的所有公共子序列中选出长度最长的那一个或几个。 例如X=[A, B, C, B, D, A, B]，Y=[B, D, C, A, B, A]，序列[B, C, B, A]和[B, D, A, B]则为X和Y的最长公共子序列，长度为4 子序列不见得一定是连续的，连续的是子串。 // 求最长公共子序列的长度 function lcs(str1, str2) { var len1 = str1.length var len2 = str2.length var dp = [] // 首先定义一个一维数组 for (var i = 0; i 8、最大公共子串 function findSubStr(str1, str2){ if (str1.length > str2.length) { [str1, str2] = [str2, str1] } // str1为长度较小的字符串 var len1 = str1.length, len2 = str2.length for (var i = len1; i > 0; i--) { for (var j = 0; j = 0) { return current } } } return \"\" } 9、最大子数组和 动态规划 O(n) dp做法是很普遍的做法，只要想出状态转移方程就可以很快做出来了。 状态转移方程：sum[i] = max{sum[i-1]+a[i], a[i]} sum[i]记录以a[i]为子序列末端的最大连续和)在dp的过程中便可以更新sum数组的最大值以及两个边界。 function findSubStr(str1, str2){ if (str1.length > str2.length) { [str1, str2] = [str2, str1] } // str1为长度较小的字符串 var len1 = str1.length, len2 = str2.length for (var i = len1; i > 0; i--) { for (var j = 0; j = 0) { return current } } } return \"\" } 10、实现类似lodash中get方法 给定一个字符串， 比如lensProp(a, obj) 返回 'obj.a'的值 function get(lens, obj) { var keys = lens.split('.') return keys.reduce((result, val) => result[val], obj) } 有问题 11、字符串反转 function reverseStr(str){ if(str.length === 1) { return str } return reverseStr(str.slice(1)) + str[0] } function reverseStr(str){ return str.split('').reverse().join('') } 12、判断一个字符串是否另一个字符串的子序列 // 判断a是否是b的子序列，双指针题目 function isSequence(a, b) { let i = 0, j = 0 while(i 14、数字反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 做法1：转换成字符串 function reverseNum(num) { let result = Math.abs(num) + '', arr = [], i = result.length - 1 while(i >= 0) { if (!(arr.length === 0 && result[i] === '0')) { arr.push(result[i]) } i-- } arr = arr.join('') return num > 0 ? arr : -arr } 做法2：数学算法 function reverseNum(num) { let result = Math.abs(num), arr = [] while(result !== 0) { let tem = result % 10 if(!(arr.length === 0 && tem === 0)) { arr.push(tem) } result = Math.floor(result / 10) } arr = arr.join('') return num > 0 ? arr : -arr } 15、判断回文数字 function huiwen(num) { num = (num + '').split('') let len = num.length let left = num.slice(0, Math.floor(len/2)) let right = num.slice(Math.ceil(len/2)).reverse() return left.join('') === right.join('') } 16、删除排序数组中的重复项 hash function huiwen(num) { num = (num + '').split('') let len = num.length let left = num.slice(0, Math.floor(len/2)) let right = num.slice(Math.ceil(len/2)).reverse() return left.join('') === right.join('') } 空数组 function filter(arr) { let result = [cur = arr[0]] for(let i = 1; i cur) { result.push(cur = arr[i]) } else { continue } } return result } 17、判断一个字符串是否另一个字符串的子串 判断一个字符串是否另一个字符串的子串，是返回位置，不是返回-1 function isSubStr(a, b) { let i = 0, j = 0, lena = a.length, lenb = b.length while(i Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-28 15:04:40 "},"Chapter9/":{"url":"Chapter9/","title":"第九章 数据结构","keywords":"","body":"第九章 数据结构 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 16:23:20 "},"Chapter10/":{"url":"Chapter10/","title":"第十章 设计模式","keywords":"","body":"第十章 设计模式 1、单例模式 2、发布订阅模式（观察者模式） 3、工厂模式 4、生产者消费者模式 1、单例模式 借助闭包实现单例模式 // 代理实现单例模式 var ProxyMode = (function() { var instance = null; return function(name) { if(!instance) { instance = new CreateUser(name); } return instance; } })(); // 测试单体模式的实例 var a = ProxyMode(\"aaa\"); var b = ProxyMode(\"bbb\"); // 因为单体模式是只实例化一次，所以下面的实例是相等的 console.log(a === b); //true 2、发布订阅模式（观察者模式） 发布订阅模式 订阅者把自己想订阅的事件注册到调度中心，当发布者发布该事件也就是该事件触发时，由调度中心统一调度订阅者注册到调度中心的处理代码。 在发布订阅模式里，发布者，并不会直接通知订阅者，换句话说，发布者和订阅者，彼此互不相识。 互不相识？那他们之间如何交流？答案是消息队列 步骤： 创建一个对象，这个对象用来存储一个缓存列表（调度中心） listen方法：用来给订阅者提供事件注册，其实就是把回调函数 fn 填加到对应event类型的缓存列表中 trigger方法：用来给发布者发布事件到调度中心，调度中心处理代码，其实就是取到 arguments 里第一个参数当做 event类型，根据 event 类型去执行对应缓存列表中的回调函数 remove方法可以根据 event 值取消订阅（取消订阅），其实就是把对应的事件从缓存列表中移除 简单实现： var event = { clientList: {}, listen: function (key, fn) { if(!this.clientList[key]) { this.clientList[key] = [] } this.clientList[key].push(fn) }, trigger: function () { var key = [...arguments].shift() var fns = this.clientList[key] if(!fns || fns.length === 0) { return false } for(let i=0, fn; fn = fns[i++];) { fn.apply(this, [...arguments]) } }, remove: function (key, fn) { var fns = this.clientList[key] if(!fns) { return false } if(!fn) { fns && (fns.length = 0) } else { for(let i=0; i 发布订阅模式与观察者模式的对比 《Learning JavaScript Design Patterns》一书这样说: “While the Observer pattern is useful to be aware of, quite often in the JavaScript world, we’ll find it commonly implemented using a variation known as the Publish/Subscribe pattern.” 虽然 Observer 模式非常有用，但是在 JavaScript 的世界中，它更多的以一种被称为发布/订阅模式的变种来实现。 观察者模式：观察者（Observer）直接订阅（Subscribe）主题（Subject），而当主题被激活的时候，会触发（Fire Event）观察者里的事件。 发布订阅模式：订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 差异： 在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。 观察者模式的耦合性要强于发布订阅模式。 观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。 观察者模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。 应用场景： 可以广泛应用于异步编程中，替代回调函数 一个对象不用再显式的调用另一个对象的接口 3、工厂模式 工厂模式是指提供一个创建对象的接口而不暴露具体的创建逻辑，可以根据输入类型创建对象。 不暴露创建对象的具体逻辑，而是将将逻辑封装在一个函数中，那么这个函数就可以被视为一个工厂。 工厂模式根据抽象程度的不同可以分为：简单工厂、工厂方法和抽象工厂。 简单工厂模式 又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。 let UserFactory = function (role) { function User(opt) { this.name = opt.name; this.viewPage = opt.viewPage; } switch (role) { case 'superAdmin': return new User({ name: '超级管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理'] }); break; case 'admin': return new User({ name: '管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据'] }); break; case 'user': return new User({ name: '普通用户', viewPage: ['首页', '发现页'] }); break; default: throw new Error('参数错误, 可选参数:superAdmin、admin、user') } } 简单工厂的优点在于，你只需要一个正确的参数，就可以获取到你所需要的对象，而无需知道其创建的具体细节。但是在函数内包含了所有对象的创建逻辑（构造函数）和判断逻辑的代码，每增加新的构造函数还需要修改判断逻辑代码。 简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用。 工厂方法模式 工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。 // 安全模式创建工厂类 var Ball = function (type,name) { // 判断实例是否属于ball if(this instanceof Ball) { var s = new this[type](name); console.log(s) return s; }else { return; } } // 工厂原型中设置创建所有类型数据对象的基类 Ball.prototype = { baoma: function(name) { this.play = function() { console.log('我在生产'+name); } }, aodi: function(name) { this.play = function() { console.log('我在建造'+name); } }, } // 客户需求 var baoma = new Ball('baoma','宝马'); // 开始建造 baoma.play(); // 客户需求 var aodi = new Ball('aodi','奥迪'); // 开始建造 aodi.play(); /* baoma {play: ƒ} 我在建造宝马 aodi {play: ƒ} 我在生产奥迪 */ 工厂方法其实就是在工厂里面去写方法，在外部写一个公用的方法去调取工厂的独有方法，来实现客户的需求。 应用场景： 对象的构建十分复杂 需要依赖具体环境创建不同实例 处理大量具有相同属性的小对象 4、生产者消费者模式 Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 19:52:51 "},"Chapter11/":{"url":"Chapter11/","title":"第十一章 前端构建","keywords":"","body":"第十一章 前端构建 1、什么是webpack，他与grunt、gulp的不同 2、什么是bundle，什么是chunk，什么是module 3、有哪些常见的Loader？他们是解决什么问题的？ 4、有哪些常见的Plugin？他们是解决什么问题的？ 5、webpack的构建流程 6、性能优化 1、什么是webpack，他与grunt、gulp的不同 1.1、 webpack 本质上，webpack 是一个JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会从入口文件的依赖开始解析，递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 在 Webpack 里一 切文件皆模块，通过 Loader转换文件，通过 Plugin注入钩子，最后输出由多个模块组合成的文件。 Webpack 专注于构建模块化项目。 一切文件如 JavaScript、 css、 scss、图片、模板，对于 Webpack来说都是一个个模块， 这样的好处是能清晰地描述各个模块之间的依赖关系，以方便 Webpack 对模块进行组合和打 包。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。 1.2、 webpack与grunt、gulp的不同？ 他们都是用于前端构建的工具。 grunt和gulp是基于任务和流（Task、Stream）的。对这些task进行一系列链式操作，更新流上的数据， 整条链式操作就构成了整个web的构建流程。 webpack是基于模块的。webpack会自动地递归解析入口需要加载的所有资源模块，然后用不同的Loader来处理不同的文件，用Plugin来扩展功能。 2、什么是bundle，什么是chunk，什么是module bundle是由webpack打包出来的文件。 chunk是指webpack在进行模块依赖分析的时候，分割出来的代码块。 module是指模块，在Webpack中一切皆模块，一个模块即为一个文件。Webpack会从Entry开始递归找出所有的依赖模块 3、有哪些常见的Loader？他们是解决什么问题的？ Loader用于对模块文件进行编译转换和加载处理，在module.rules中进行配置，它用于告诉Webpack在遇到哪些文件时使用哪些Loader去加载和转换。 babel-loader：把 ES6 转换成 ES5 awesome-typescript-loader：解析ts语法 url-loader：打包静态文件（图片）（大于limit时用file-loader） css-loader：加载 CSS模块，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到页面中 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 eslint-loader：通过 ESLint 检查 JavaScript 代码 4、有哪些常见的Plugin？他们是解决什么问题的？ Plugin可以扩展webpack的功能，这些扩展功能可以参与到整个webpack打包的各个流程(生命周期)。 实现原理是在构建流程里注入钩子函数。 每一个内部插件，都是通过监听任务点的方式，来实现自定义的逻辑 DefinePlugin：定义环境变量 commons-chunk-plugin：提取公共代码 CleanWebpackPlugin：清除dist目录 MiniCssExtractPlugin：将CSS提取为独立的文件 【tips】什么是钩子函数？ 钩子函数：钩子函数是在一个事件触发的时候，在系统级捕获到并做一些操作，一段用以处理系统消息的程序。“钩子”就是在某个阶段给你一个做某些处理的机会。 钩子（hook）函数就是处理拦截在软件组件之间传递的函数调用或事件或消息的代码 在计算机编程中，钩子函数主要用于通过拦截在软件组件之间传递的函数调用（或消息/事件）来改变或增强操作系统，应用程序或其他软件组件的行为。处理这种截获的函数调用，事件或消息的代码称为钩子，它的本质就是用以处理系统消息的程序，通过系统调用，把它挂入系统。钩子函数可用于许多目的，包括调试和扩展功能。常见的钩子函数：react的生命周期函数、vue的生命周期函数等。 5、webpack的构建流程 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归的完成所有文件的处理； ​ 使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置中的输出路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到对应的事件后会执行相应的处理逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 6、性能优化 用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。 提取公共代码，减少打包体积 CommonsChunkPlugin->splitChunks 压缩代码 删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?optimization.minimizer.OptimizeCSSAssetsPlugin）来压缩css 使用UglifyJS插件压缩JS代码时，需要先将代码解析成Object表示的AST（抽象语法树），再去应用各种规则去分析和处理AST，所以这个过程计算量大耗时较多。ParallelUglifyPlugin可以开启多个子进程，每个子进程使用UglifyJS压缩代码，可以并行执行，能显著缩短压缩时间。 减少构建搜索或编译路径 --优化Loader的文件搜索范围：增加exlude，include缩小搜索范围 --设置resolve.modules:[path.resolve(__dirname, 'node_modules')]避免层层查找 --对庞大的第三方模块设置resolve.alias resolve.alias:{ 'react': path.resolve(__dirname, './node_modules/react/dist/react.min.js') } 或 resolve: { alias: { 'react-dom': '@hot-loader/react-dom' } } --合理配置resolve.extensions，减少文件查找 多进程处理 happypack 的原理是让loader可以多进程去处理文件 利用CDN加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径 删除死代码（Tree Shaking） 将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数--optimize-minimize来实现 缓存与增量构建 把Babel编译过的文件缓存起来，下次只需要编译更改过的代码文件即可 loader: 'babel-loader?cacheDirectory=ture' DllPlugin DllPlugin可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案. Copyright © shanshan 2020 all right reserved，powered by Gitbook该文章修订时间： 2020-02-26 19:27:03 "}}