# 第五章 安全

<!-- toc -->

- [1、XSS攻击](#1、xss攻击)
- [2、CSRF攻击](#2、csrf攻击)
  <!-- tocstop -->



## 1、XSS攻击

#### 1.1、XSS 攻击是什么

**XSS 攻击(Cross Site Scripting，跨站脚本攻击)：**它是通过对网页注入可执行的恶意脚本且成功地被浏览器 执行，从而达到攻击的目的，例如获取用户的敏感信息如 Cookie/SessionID、导航到恶意网站、携带木马等，进而危害数据安全。

XSS 的本质是：**恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。**

而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。

例如，当一个form表单中来自用户的输入变成 `"/><script>alert(document.cookie)</script><!-` 

`<input type="text" name="address1" value=""/><script>alert(document.cookie)</script><!- ">`

事件被触发的时候嵌入的JavaScript代码将会被执行。



**用户是通过哪种方法“注入”恶意脚本的呢？**

- 来自用户的 UGC 信息
- 来自第三方的链接
- URL 参数
- POST 参数
- Referer （可能来自不可信的来源）
- Cookie （可能来自其他子域注入）



#### 1.2、XSS攻击方式

XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。

- **反射型XSS 攻击**

反射型XSS，也叫非持久型XSS

这种攻击方式往往需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。

从概念上可以看出，反射型XSS代码是首先出现在URL中的，作为参数提交到服务器，然后需要服务端解析并响应，最后需要浏览器解析之后XSS代码才能够攻击。

**总结来说，就是恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。**

- **存储型XSS攻击**

**存储型 XSS 会把用户输入的数据 "存储" 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。**这种 XSS 攻击具有很强的稳定性。

比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。

存储型 XSS 将恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性，比较常见场景是在博客，论坛等社交网站上。

- **DOM型xss攻击**

**基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。**

（1）攻击者构造出特殊的 URL，其中包含恶意代码。

（2）用户打开带有恶意代码的 URL。

（3）用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。

（4）恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，**属于前端 JavaScript 自身的安全漏洞**，而其他两种 XSS 都属于服务端的安全漏洞。



#### **1.3 XSS漏洞修复**

**攻击防范**

- **HttpOnly 防止劫取 Cookie**

HttpOnly 最早由微软提出，至今已经成为一个标准。浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。

攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

- **输入检查（**XSS Filter**）**

**对于用户的任何输入要进行检查、过滤和转义**。建立可信任的字符和 HTML 标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。

在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含< ，>等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。



## 2、CSRF攻击

#### 2.1、CSRF攻击是什么

CSRF（Cross-site request forgery），跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

你这可以这么理解CSRF攻击：**攻击者盗用了用户的身份，以该用户的名义发送恶意请求**。CSRF能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账......造成的问题包括：个人隐私泄露以及财产安全。

完成一次CSRF攻击，受害者必须依次完成两个步骤：

　　1.登录受信任网站A，并在本地生成Cookie。

　　2.在不退出A的情况下，访问危险网站B。

CSRF攻击的本质原因：源于Web的隐式身份验证机制。Web的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的。CSRF攻击的一般是由服务端解决。

#### 2.1、CSRF防御

###### **2.2.1、验证 HTTP Referer 字段**

根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。

例如：https://github.com/zbcwilliam/zhihu_spider 是从简书地址https://www.jianshu.com/p/1007e8b26338跳转过来的，那么在打开上述git地址时，请求头中的**Referer字段**: https://www.jianshu.com/go-wild?ac=2&url=https%3A%2F%2Fgithub.com%2Fzbcwilliam%2Fzhihu_spider，就可以表明这是一个由外部地址跳转过来的不可信任地址。

因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。

这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

缺点：对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。即便是使用最新的浏览器，黑客无法篡改 Referer 值，用户自己也可以设置浏览器使其在发送请求时不再提供 Referer。

###### 2.2.2、 在请求地址中添加 token 并验证

CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

###### 2.2.3、 浏览器Cookie策略

IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。

PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。

PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。

###### 2.2.4、 加验证码

验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。

###### 2.2.5、 Referer Check

Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。

但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。

###### 2.2.6、 Anti CSRF Token

现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。

例子：

1. 用户访问某个表单页面。

2. 服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。

3. 在页面表单附带上Token参数。

4. 用户提交请求后， 服务端验证表单中的Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。

**这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。**

**注意：**

CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。



**二者对比：CSRF与XSS差别很大，XSS利用的是站点内的信任用户，而CSRF则是通过伪装来自受信任用户的请求来利用受信任的网站。**



**【参考】**

[前端安全系列（一）：如何防止XSS攻击](https://tech.meituan.com/2018/09/27/fe-security.html)

[CSRF 攻击的应对之道](https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/index.html)

[浅说 XSS 和 CSRF](https://www.jianshu.com/p/855395f9603b)

